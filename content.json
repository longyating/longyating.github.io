{"meta":{"title":"龙娅婷","subtitle":"Long Yating","description":"欢迎来到龙娅婷的个人网站","author":"longyating","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2019-02-26T13:00:27.000Z","updated":"2020-10-13T13:45:01.311Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"欢迎来到这里。 关于博客 本站采用Hexo3.8.0框架，使用Snippet主题，托管于GitHub。 搭建过程中按时做了笔记总结，并同步更新于hexo使用笔记（持续更新），作为日后参考查看。 关于我 95年天蝎座，一个有点文艺的工科女。 通信工程专业，18年毕业于郑州大学，现就读于北京邮电大学。 静若处子，动若脱兔。 闲下来喜欢弹弹吉他、打打网球。 我乐于与朋友分享生活，但是喜欢并享受独处。 对一切新鲜事物保持好奇心。 联系我 文章评论：欢迎在文章下面评论，评论时留下邮箱，有回复就会邮件提醒你。我的评论回复昵称：小龙童靴。 网易云音乐：小龙女Fingerstyle B站：小龙女Fingerstyle 邮箱：longyating@bupt.edu.cn 唠唠嗑 用的最多的 App 要属网易云音乐了吧。对我来说这不仅是一个听歌软件，也是我的心灵栖息地。在这里我认识了一些很有趣的人，一起交流吉他，互相学习。因为弹琴得以结识老甘，要从你身上学习的东西太多啦！ 2016年10月份大三开始接触吉他，从此吉他便融入了我的生活，成为不可或缺的一部分。 2018年7月份，大学毕业季正式出了我的第一个吉他视频愿樱，实现自己许久以来想拍一个带动漫的指弹视频愿望。由我的好朋友沨完成拍摄剪辑，后来他教会了我视频剪辑，自己也陆续独立做了几个视频，嘻嘻。在此期间，粥羊羊对我提供了很多帮助，将我录制的音频完成混音，音质有了明显的提升。在此特别感谢二位！(✿◡‿◡)。将学会的指弹曲目录制下来，作为学琴记录。以后听到自己弹过的曲子，应该会回忆起曾经那些练琴的夜晚吧。 大学期间，和我的老铁室友镜娴，都很喜欢一个民谣组合，叫房东的猫，由两个大学生妹子组成。开玩笑说以后我们也组一个组合。赶着毕业的尾巴，我们出了首张翻唱单曲《Safe And Sound》，专辑就命名为『楼管的狗』，发布于网易云。作为我们有爱的见证，也是毕业留念。可以点击收听："},{"title":"guestbook","date":"2019-02-28T08:45:34.000Z","updated":"2019-02-28T08:45:49.043Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/index.html","excerpt":"","text":""}],"posts":[{"title":"在字节跳动实习的日子","slug":"bytedance","date":"2020-10-10T08:43:07.000Z","updated":"2020-10-13T14:23:02.901Z","comments":true,"path":"bytedance/","link":"","permalink":"http://yoursite.com/bytedance/","excerpt":"","text":"2020年发生了很多事情。总结下过去的大半年吧。酸甜苦辣都在心头~ 回顾过去时间回到2020年，年初。现在是研二下了。全国被疫情的恐怖氛围弥漫，学校停课，公司停工，全国人民都被困在家里。而我，也迎来了艰难的一年。两件大事：找实习+中小论文。 找实习，目标很明确，就找互联网行业。一方面，自己对互联网的自由活跃的氛围很向往。于是也在研究生期间利用课余时间学习了Java；另一方面，互联网实习经历含金量高，可以给简历镀金。如果实习了发现不喜欢这种工作节奏，也可以秋招投递国企。 然而，在这个时候，我连一个拿的出手的Java项目都还没有。 于是我利用这个寒假，自己在牛客网做了个项目。使用Java语言，基于SpringBoot框架，做了个网站。中间投递了字节的算法岗，因为自己研究生期间的研究方向与此相关。这是我的第一次面试，不出所料，一面就挂了。为什么明知道要挂，却还是投递呢？主要是想感受下差距以及确定自己今后的岗位方向。虽然研究生期间做机器学习，但是对于机器学习仅仅停留在使用层面，涉及到底层实现我并不是很清楚。加之近几年来，算法岗竞争火热程度，经过这次面试水，我决定彻底放弃算法。确定了以下的路线：大厂投测开，中厂投研发。 确定好目标后，就要为之安排学习计划了。我就不信我一个北邮的研究生还能找不到实习。LeetCode刷起来，面经背起来~ 然而，学习通信的我，非科班出身，在互联网这条路上走的并不是很顺利。 一开始，做笔试时，连怎么输入测试用例都不会，还没有从平时做LeetCode的那种只写方法的模式中切换过来，这就导致很多公司，笔试都没有过。比如网易。 后面陆续面试了一些公司，都挂在了各个环节。最可惜的还是阿里了，一二面面试官对我评价极其之高，甚至主管加了我微信，当时一度感觉自己稳了。然后，三面leader面挂了。事后问其原因，说是自己热情不够，说感觉我如果遇到问题不会就这样放过去了，缺乏探索精神。要是说我算法题没写出来，我也认了这个原因，毕竟DP一直就是我的弱项。为什么会是这样的评价，应该是中间三面面试官问了我一个问题，你觉得做算法和做工程有什么区别？而我非常的实诚，我觉得我在做算法的过程中，我感觉它很玄学，比如调参，有时候忽然就好用了。而做工程，我觉得一步一个脚印，很踏实。而就是这样的一个看似我随口的回答，却折射出来一些我自己都没有意识到的致命点——我确实缺乏刨根问底的精神。（以后应该怎么改进？）在得知被挂掉的那天晚上，我忍不住痛哭了起来，甚至陷入了自我怀疑。金三银四，现在已经是四月底了，而我一个offer都没有。 5月，天气也渐渐变暖了，我决定和我妹一起早起。早上起来，先刷两道算法题抖擞精神。现在的我，感觉也没有那么强烈的心情找实习了，实在不行就面向秋招吧。算法题还是要刷，基础知识还是要复习。但是，不要给自己那么大压力了。一边复习，然后又投了几个二线大厂，也不抱那么高的期望了。就当为秋招积累经验。 有一天，一个师兄问我，要不要投字节的实习。怀着很忐忑的以及超级的不自信的心情，抱着试一下的态度，我投递了字节抖音客户端研发岗。面试。三轮技术面+一轮HR面。也许是题目没有那么难，也许是我这段时间刷题量变终于产生了质变，我从未如此顺利，每一面的算法题都做出来了。在一个晚上，HR一个电话打过来，“恭喜，你被录取了！”我听到这个消息，眼泪都差点掉出来。三四个月找实习的各种碰壁，终于在拿到字节的offer的时候，那一刻，感觉一切都值了。从一面到拿到offer，只用了不到一周的时间。字节的效率真的是高。 后来那个月特别顺利，早上刚刷的题，晚上面试就碰到原题，紧接着也收获了滴滴的Java开发offer，但是鉴于对字节的情怀以及字节可以远程实习，最后签了字节。再有其他厂约面就直接拒掉，没再面了。至此，终于可以结束这苦逼的找实习经历了。 六月，远程入职。 于是，我就从一种忙碌，转变到了另外一种忙碌。但是我并不能全身心投入到实习上，小论文还没中。这段期间，实习和实验室需要我权衡。在此期间，还被实验室安排了一次紧急任务。上班时间做实习，下班时间搞实验室。连续好几天睡眠不足6小时。一直在切换工作，效率低下，身疲力竭。 而在那段时间，每天最幸福的事情，就是傍晚去田野里玩滑板。因为那个时候，公司刚好完成每日工作交流汇报。导师在国外的时间是晚上，也不会找我。迎着风，都是放松惬意的感觉。 随后还经历了一些特别闹心的事情，是关于返校的。公司那边的导师一直让我到公司，因为我现在已经过了基础知识学习期，需要到公司和其他同事合作做需求了。而北京高校政策，不允许学生回京。因此，我在家度过了很长一段的远程实习，也正因为此，在学校开学后，我第一时间到了公司，度过了很忙碌的一个多月，恶补功课。也正是因为前期落下太多，我担心自己产出不够，虽然已经满足了申请转正的要求（技术序列出勤40的工作日），但却迟迟没有提这个事。等到自己终于有了点产出，PPT能写东西了，那会已经是九月中下旬了。我错过了很多公司的秋招，现在，一切都压在转正这个事情上了，给了自己很大的压力。所幸的是，答辩很顺利，我拿到了字节秋招的正式offer。 在字节的日子然后说说在字节的日子吧! 新人培养来字节之前，我听说字节新人培养制度很差，基本靠自学，还没怎么学会就赶鸭子上架做需求了。 而实际上，就我的情况而言并非如此。 字节是导师一对一制度，会为每个新人分配一个mentor（mentor，意思为导师，一般指工作方面的指导者和引领者）。我的mentor是有着十几年工作经历的架构师，真的是令我仰望的大佬级别。虽然为远程实习，我的mentor为我专门安排了日历，每天傍晚五点半给我打视频电话，短则十几分钟，长则一个半小时。主要为看我今天学习了什么，到了什么进度，遇到了什么问题，指导下一步学习。不得不说，我的mentor真的是超级耐心负责，也很幽默有趣。包括后面，我申请实习转正，mentor一天一版本帮我改正PPT，改了四个版本，并给我安排模拟答辩，可以说是对我的工作很上心了。何其幸运，遇到这样的mentor。谁要说字节没有新人培养制度，我第一个站出来跟他理论哈哈。 工作环境办公区很整洁宽敞，人体学工程椅确实很舒适。 入职即配备高配版MacBook Pro，另外研发岗实习工资 400/天。一个字：香！ 技术氛围字节是一家特别重视技术的公司。周围同事特别优秀，追求极致的态度真的令我佩服。PS：我听周围同事说字节有一半都是北邮人，不知是否属实，但是还是可以看出，我们北邮盛产程序员啊23333。 小组的氛围挺不错的，我们新人之间经常分享学习资料，一起学习进步。遇到不会的，就要请教组里的大神了，都很耐心解答我们遇到的问题。 但是不得不说，在每周产品上线那个晚上，真的是提心吊胆，各种被block的时候紧紧张张。等到代码成功合入，按时上车，感觉如释重负。 工作时间我看《员工手册》上是这样说的：弹性工作制，上下班不打卡，但是需要满足8小时工作制。 实际也大致如此，组里的正式员工们上班都比较晚，走的也比较晚。我的话，一般在学校8点起床，9点出门，骑车半小时9:30到公司，去公司食堂吃早饭。10点坐到工位上。而此时，工位，空空如也，所以我基本每天都是第一个到的，但我也基本是第一个走的哈哈哈。到了12点去吃午饭，中午有两个小时的休息时间，一般大家默认下午14:00点开始干活了。到了15:00~16:00点钟，就是下午茶时间了。一直到晚上19:00点供应晚饭，大家就结束下午的工作了。如果想去健身房的话，一般也是这个时间大家去的多。吃完饭回来不到20:00吧，晚上再干会活，基本上我到了九点多点就准备撤了。如果有需求忙着上线的话，晚上工作到十点多也是会发生的事。 食堂字节是出了名的食堂好吃。三餐免费 + 免费下午茶 + 不限量零食。总之，公司在吃的这个方面，也是追求极致了。哈哈。而且，都是免费的。 平时还是是自助吃的多，偶尔也会吃健身餐，如下。 不重样下午茶 如果过节，还会有各种高大上的礼品。端午粽子礼盒 中秋月饼礼盒 还会有各种小礼品，而且都很精致。人文关怀很到位。 业余活动平时工作日其实可以自由支配的时间并不多，但是如果不是很忙的话，可以抽时间去健身房锻炼的。而且每天还会有各种课，比如拳击，瑜伽等等。 团建九月底大部门组织了一次团建，70多个人，其中妹子只有7个，而且其中还包括几个PM小姐姐。我们开发的妹子真的是稀有物种啊。团建去了北京延庆，当天下午的活动是辩论会，还有PM和各部门组长分享最近的进展。总之就是开会哈哈。结束了之后就是晚饭时间啦。 晚饭后，度假村自带的活动，许多人在跳舞 狼人杀玩的还是很心累的，完全跟不上大佬们的思维逻辑。也见识了我们leader果真太厉害了。不过我还是凭借我的第六感，辨别出来他就是狼哈哈哈啊哈。 晚上，和另外一个同事小姐姐一起住，环境很舒适～ 第二天去户外玩，被网球姿势支配的我，打起羽毛球都感觉乱入哈哈。 最后附上一幅图，是月饼礼盒上画的，很喜欢。 在字节实习的日子结束啦，回想这大半年，为了这个实习，真的是花费了很多时间精力。跟实验室的事情权衡劳心费神，我发现我并不适合同一阶段做两件事情。好在最后，实习转正了，论文也中了。年初定的目标所幸都实现了。 越努力，越幸运~以后的日子，继续加油吧~！","categories":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}],"tags":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/tags/随笔杂记/"}],"keywords":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}]},{"title":"操作系统","slug":"caozuoxitong","date":"2020-04-16T13:48:37.000Z","updated":"2020-04-23T14:12:30.035Z","comments":true,"path":"caozuoxitong/","link":"","permalink":"http://yoursite.com/caozuoxitong/","excerpt":"","text":"内核态与用户态面试考点 进程和线程的区别进程进程是资源分配的基本单位。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 线程线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 区别Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 进程间通信。 进程的状态 就绪状态（ready）：等待被调度 运行状态（running） 阻塞状态（waiting）：等待资源 应该注意以下内容： 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 孤儿进程和僵尸进程孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 僵尸进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。 进程间的通信方式有哪些？（1）管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 （2）命名管道 (named pipe) ：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 （3）信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 （4）消息队列( message queue ) ：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 （5）信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 （6）共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 （7）套接字( socket ) ：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 随机读写和顺序读写的区别和优缺点？随机和顺序读写，是存储器的两种输入输出方式。 随机读写占用空间多，但速度快，便于进行数据处理zhidao，而顺序读写速度慢，空间小，数据处理复杂 随机和顺序读写，是存储器的两种输入输出方式。 存储的数据在磁盘中占据空间，对于一个新磁盘，操作系统会将数据文件依次写入磁盘，当有些数据被删除时，就会空出该数据原来占有的存储空专间，时间长了，不断的写入、删除数据，就会产生很多零零散散的存储空间，就会造成一个较大的数据文件放在许多不连续的存贮空间上，读写些这部分数据时，就是随机读属写，磁头要不断的调整磁道的位置，以在不同位置上的读写数据，相对于连续空间上的顺序读写，要耗时很多。 在开机时、启动大型程序时，电脑要读取大量小文件，而这些文件也不是连续存放的，也属于随机读取的范围。","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"Mysql要学习的不仅仅是增删改查","slug":"Mysql","date":"2020-04-14T16:04:22.000Z","updated":"2020-05-21T03:39:01.748Z","comments":true,"path":"Mysql/","link":"","permalink":"http://yoursite.com/Mysql/","excerpt":"","text":"Mysql引擎类型Mysql数据库引擎该如何选择？ 索引有什么副作用吗？（1）索引是有大量数据的时候才建立的，没有大量数据反而会浪费时间，因为索引是使用二叉树建立. （2）当一个系统查询比较频繁，而新建，修改等操作比较少时，可以创建索引，这样查询的速度会比以前快很多，同时也带来弊端，就是新建或修改等操作时，比没有索引或没有建立覆盖索引时的要慢。 （3）索引并不是越多越好，太多索引会占用很多的索引表空间，甚至比存储一条记录更多。对于需要频繁新增记录的表，最好不要创建索引，没有索引的表，执行insert、append都很快，有了索引以后，会多一个维护索引的操作，一些大表可能导致insert 速度非常慢。 主键和外键成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键 区别 主键 外键 索引 定义 唯一标识一条记录，不能有重复的，不允许为空 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 该字段没有重复值，但可以有一个空值 作用 用来保证数据完整性 用来和其他表建立联系用的 是提高查询排序的速度 个数 主键只能有一个 一个表可以有多个外键 一个表可以有多个唯一索引 事务事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性Atomicity：原子性指的是事务是一个不可分割的，要么都执行要么都不执行。 一致性Consistency：在一致性状态下，所有事务对同一个数据的读取结果都是相同的。 隔离性Isolation：指的是一个事务的执行，不能被其他的事务所干扰。 持久性Durability：持久性指的是一个事务一旦提交了之后，对数据库的改变就是永久的。 并发一致性问题 读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 不可重复读： T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 幻影读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 事务隔离级别 未提交读：事务中的修改，即使没有提交，对其它事务也是可见的。 提交读：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 可重复读：保证在同一个事务中多次读取同一数据的结果是一样的。 可串行化：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。 聚集索引和非聚集索引的区别？聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大。 非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置，非聚集索引检索效率比聚集索引低，但对数据更新影响较小。 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续 聚集索引：物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序 非聚集索引：物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序. 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。 设计三范式 第一范式：强调的是列的原子性，列不能分成其他几列，第一范式就是无重复的域。 第二范式：首先是在第一范式的基础上，另外包含两部分的内容，一是表必须有主键，二是没有包含在主键中的列必须完全依赖于主键，二不能只依赖于主键的一部分。 第三范式：在第二范式的基础之上，非主键列必须直接依赖于主键不能存在传递依赖。 目的：消除冗余，单纯依赖关系。不允许数据库表出现冗余字段，不允许表之间多重依赖 MySql慢查询MySQL的慢查询，全名是慢查询日志，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。 具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。 long_query_time的默认值为10，意思是记录运行10秒以上的语句。 默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。 查询数据库比较慢可能是哪些原因造成的？1、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷)2、I/O吞吐量小，形成了瓶颈效应。3、没有创建计算列导致查询不优化。4、内存不足5、网络速度慢6、查询出的数据量过大（可以采用多次查询，其他的方法降低数据量）7、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷)8、sp_lock,sp_who,活动的用户查看，原因是读写竞争资源。9、返回了不必要的行和列10、查询语句不好，没有优化 如何解决慢查询问题要解决慢查询，就是优化这些查询缓慢的语句，或是重新组织自己的数据。重新组织数据的表现形式是分表。对于成熟的业务系统而言，分表的代价是极高的。所以如何组织一张表仍然是建表的重要决策。因此，优化语句才是解决慢查询的基本方法。 加索引 使用LIKE关键字的查询语句在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。 使用多列索引的查询语句MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。 优化数据库结构合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。 将字段很多的表分解成多个表对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。 增加中间表对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。 分解关联查询将一个大的查询分解为多个小查询是很有必要的。很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联 Limit分页分页是一个常见的情景。分页通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。但是，当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，MySQL需要查询10020条，但是只返回最后20条，这样的代价很高。优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。 参考文献常见Mysql的慢查询优化方式MySQL中的慢查询关于MySQL 通用查询日志和慢查询日志分析","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"测试知识","slug":"ceshi","date":"2020-04-14T15:46:54.000Z","updated":"2020-04-21T14:08:53.756Z","comments":true,"path":"ceshi/","link":"","permalink":"http://yoursite.com/ceshi/","excerpt":"","text":"测试要点（功能、界面、性能、安全、可用性、兼容）测试登录注册页面测试网页版淘宝购物车测试百度搜索引擎测试的流程？1、需求：阅读需求，理解需求，与客户、开发、架构多方交流，深入了解需求。–testing team2、测试计划: 根据需求估算测试所需资源（人力、设备等）、所需时间、功能点划分、如何合理分配安排资源等。—testing leader or testing manager3、用例设计：根据测试计划、任务分配、功能点划分，设计合理的测试用例。—testing leader, senior tester4、执行测试：根据测试用例的详细步骤，执行测试用例。–every tester(主要是初级测试人员)5、执行结果记录和bug记录：对每个case记录测试的结果，有bug的在测试管理工具中编写bug记录。–every tester(主要是初级测试人员)6、defect tracking：追踪leader分配给你追踪的bug.直到 bug fixed。–every tester7、测试报告：通过不断测试、追踪，直到被测软件达到测试需求要求，并没有重大bug.8、用户体验、软件发布等。 测试的分类","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"设计模式","slug":"shejimoshi","date":"2020-04-14T13:27:46.000Z","updated":"2020-04-22T00:51:03.093Z","comments":true,"path":"shejimoshi/","link":"","permalink":"http://yoursite.com/shejimoshi/","excerpt":"","text":"Spring中用到了哪些设计模式23种设计模式深入解析，史上最通俗易懂的设计模式讲解 单例模式 懒汉式-线程不安全以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。 饿汉式-线程安全线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。 懒汉式-线程安全只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。 双重校验锁-线程安全（重点）uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。123456789101112131415public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。12345if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; uniqueInstance = new Singleton(); &#125;&#125; 静态内部类实现 枚举实现工厂模式简单工厂模式该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象.工厂方法模式简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂抽象工厂模式上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品Phone（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。从上面类图结构中可以清楚的看到如何在工厂方法模式中通过增加新产品接口来实现产品的增加的。 接下来我们继续通过小米和苹果产品生产的例子来解释该模式。 为了弄清楚上面的结构，我们使用具体的产品和工厂来表示上面的UML类图，能更加清晰的看出模式是如何演变的：","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"http必知必会","slug":"https","date":"2020-04-12T02:43:35.000Z","updated":"2020-05-22T05:21:34.102Z","comments":true,"path":"https/","link":"","permalink":"http://yoursite.com/https/","excerpt":"","text":"Http报文头里有什么有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 Http与Https区别1、https协议需要到CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。) HTTPS优缺点 优点： HTTPS传输数据过程中使用密钥进行加密，所以安全性更高 HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器 缺点： HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加 HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高 常见的14种状态码状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。 组合方式 类别 原因短语 1XX Informational（信息性状态码） 接受的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 2XX——表明请求被正常处理了1、200 OK：请求已正常处理。 2、204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。 3、206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。 3XX——表明浏览器需要执行某些特殊的处理以正确处理请求4、301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。 5、302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。 302是在HTTP/1.0协议中提出来的，而303和307则是在HTTP/1.1中提出，可以将303和307看作是对于302的一个细化. 6、303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。 当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。 7、304 Not Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.。 8、307 Temporary Redirect：临时重定向。与302有相同的含义。不会从post变为get。但是对于处理响应时的行为，各种浏览器有可能出现不同的情况。 4XX——表明客户端是发生错误的原因所在。9、400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。 10、401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。 11、403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等） 12、404 Not Found：服务器上没有请求的资源。路径错误等。 5XX——服务器本身发生错误13、500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。 14、503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。 参考文献Http与Https区别常见的14种状态码","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"什么是BIO、NIO、AIO？","slug":"BIO","date":"2020-04-09T07:49:15.000Z","updated":"2020-04-12T02:46:01.101Z","comments":true,"path":"BIO/","link":"","permalink":"http://yoursite.com/BIO/","excerpt":"","text":"同步和异步 同步： 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。 异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。 同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。 阻塞与非阻塞 阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。 非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。 组合 组合方式 性能分析 举例 同步阻塞 最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。 有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。 同步非阻塞 提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。 这种方式通常能提升 I/O 性能，但是会增加CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。 NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。 异步阻塞 异步阻塞这种方式在分布式数据库中经常用到，例如在网一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。 异步非阻塞 这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高。 AIO为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。 BIO (synchronous Blocking IO) 同步阻塞NIO (synchronous Non blocking IO) 同步非阻塞AIO (Asynchronous non blocking IO) 异步非阻塞简而言之，同步和异步最关键的区别在于同步必须等待（BIO）或者主动的去询问（NIO）IO是否完成，而异步（AIO）操作提交后只需等待操作系统的通知即可。 各自适用场景BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 Java核心（五）深入理解BIO、NIO、AIOJava面试常考的 BIO，NIO，AIO 总结IBM | 深入分析 Java I/O 的工作机制BIO、NIO和AIO的区别、三种IO的原理与用法","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"job","slug":"job","date":"2020-03-20T12:26:49.000Z","updated":"2020-04-22T10:01:54.875Z","comments":true,"path":"job/","link":"","permalink":"http://yoursite.com/job/","excerpt":"","text":"3.20 阿里技术风险部测试开发工程师一面 自我介绍 介绍项目 项目的难点，为什么要用生产者消费者模式，有什么好处和弊端?我引出使用了redis做缓冲区 ，可能带来的 雪崩，穿透，击穿问题。解释下名词的意思以及怎么解决？ 为什么用redis，选择的过程中有没有和其他的类似产品做对比 设计模式知道哪些？ Mybatis 怎么用的 Maven 怎么用的 为什么做了压测？怎么测的？ JVM 了解吗？说一说 数据库除了增删改查还会什么? 数据库索引底层用的什么数据结构？ Spring 说说，看过底层实现吗？ 容器了解吗？说说你比较熟悉的容器 线程池了解吗？ 扩展题：一个100G的文件，内存只有128M，如何对其进行全排序？分割，单独排序，再合并排序整体问的很广，没有问特别具体的问题，面试官人很Nice！给我自由发挥的比较多。 3.22 阿里菜鸟Java开发工程师一面 自我介绍（说下成绩排名） hashmap 底层实现（注意1.7 和 1.8区别） 在计算数字在数组中的索引位置的时候，为什么要用现在这种方式，为什么不用xx等方式（没听过的名词） 扩容流程，是几倍扩的（2倍）？有什么好处？ concurrenthashmap 底层实现。（注意1.7 和 1.8区别） 反射原理？ 有没有用过BIO/NIO? 类加载机制是什么？ 如果有两个String类，怎么判断是不是一个类？ 如何强制一个类加载（这个题目没听懂什么意思，大致意思就是强制啥的） synchronized 与 lock 的区别 什么是公平锁和非公平锁 AQS是如何实现公平锁和非公平锁 对项目中哪一个中间件比较熟悉？我回答了redis redis底层怎么实现的？ redis穿透是什么，如何解决？ 布隆过滤器有什么缺点? 线程池中corePoolSize, maximumPoolSize, workQueue 参数是什么意思？我回答了参数的意思，并把添加任务的流程说了下。 ThreadLocal 什么作用，什么优缺点？底层怎么实现复制变量副本的？ 扩展题：假设你的开发了一个项目，有网页版本和APP版本，假设你已经登录APP版本，怎么实现扫码登录网页版本 4.12 字节跳动一面 重载与重写区别 访问一个网页的过程，并且是Https。从输入到（包含服务器代理方面） Http协议是哪一层？ TCP 是哪一层？ Http 和 TCP 之间 Https与 Http 区别？ Http package包含什么内容 为什么需要反向代理？ 操作系统：内核态与用户态？ 说一下对redis的了解 底层实现：跳表原理，与树的区别 gc 算法题：ASCII字符串转十六进制 4.14 快手一面 MySQL 出现慢查询，怎么排查原因？ MySQL 有哪些索引？ 聚簇索引与非聚簇索引 索引的结构？跳表 为什么使用B+树？ SpringBoot 使用过哪些注解？ Bean类加载的方式？配置文件的方式 Hashmap?是不是线程安全？什么场景会出现线程不安全的情况？死链问题是什么意思？什么场景下产生的？扩容的时候会发生死链 concurrent包里面的锁？ 什么是可重入锁？ A线程进来拿到锁了？然后B线程进来会怎么样？什么时候唤醒它？ B进入队列，然后自旋，什么时候触发再一次拿锁?A线程释放的时候，给队列发送信号。B监听前一个节点，如果前一个节点发生了变化，会把信号通知到后面。 虚拟机内存有哪几块区域？ 详细说下堆 spring中AOP使用场景？有哪些实现方式？AOP常用的实现方式有两种，一种是采用声明的方式来实现（基于XML），一种是采用注解的方式来实现（基于AspectJ）。 AOP所用的注解有什么？@Aspect@Before@After 你用过哪些设计模式？ Linux下指令，查询日志异常是什么指令？tail -n 10 test.log 查询日志尾部最后10行的日志;tail -n +10 test.log 查询10行之后的所有日志;head -n 10 test.log 查询日志文件中的头10行日志;head -n -10 test.log 查询日志文件除了最后10行的其他所有日志; Http和Https区别？ 算法题：1）层序打印二叉树2）链表反转 4.15 阿里二面4.22 阿里三面 自我介绍 算法题。第一题不会，于是又给我加了第三题。做了二三。1）对于一个文件，输出出现最多次数的单词2）字符串排序，按照ascii码的顺序，实现方式不限3）字符串压缩：“aaabbccdabc”=&gt;”a3b2c2d1a1b1c1” 做知识问答网站的目的？学习目的or导师任务 Spring框架几个特性是什么？（Ioc, AOP） 面向切面怎么用的？ 数据库使用mybatis与JDBC怎么连接？ 初始化哪些Bean，加载哪几个类才能建立连接？ Maven 启动的时候jar包冲突，有没有遇到过这一块问题，怎么解决？ 我说做单元测试的时候用到了，问我单元测试怎么做的？ redis 缓存做什么用？ redis 持久化数据怎么用的？（没用到，提了下RDB AOF） redis 数据存在哪里？我说只做了单机，没有做分布式，真嘴欠，引出这个分布式，又没了解过这方面知识 分布式怎么做到会话保持？也就是session怎么共享？ 多台服务器怎么实现负载均衡？nginx怎么做到的？（问过两次了！！！一定要看） HTTP 协议说下，是在哪一层。 HTTP 请求方式有哪些（get post） get 和 post 有什么区别 restfull 和 soap 这一块web API调度规范？如何做一个web API？ RequestMapping 使用的是哪一种规范？答案是 restfull 深度强化学习做这个项目的背景？讲一下这个项目 怎么验证这个结果？通过仿真还是什么？ 最终和基准比优化了多少？比例 基于这个结果发了文章，投到哪个期刊？ 其他论文的情况 参加比赛的情况，参赛作品是什么？ 什么叫线程安全，引出锁的概念。 StringBuilder 和 StringBuffer 哪个是线程安全？ 你觉得测试开发是什么样的工作？ 反问环节？问实习生的培养模式？师兄文化，两到三个月的成长计划，参与项目，学习阿里的技术栈。有一些小的实现。开发和测试两个维度。最后转正答辩，以成果作为答辩依据。","categories":[],"tags":[],"keywords":[]},{"title":"redis：一个神奇且强大的数据库","slug":"redis","date":"2020-03-20T02:24:14.000Z","updated":"2020-05-14T14:49:12.889Z","comments":true,"path":"redis/","link":"","permalink":"http://yoursite.com/redis/","excerpt":"","text":"简介Redis是一个高性能的key-value数据库。支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。安装及入门查看：https://www.jianshu.com/p/56999f2b8e3b 使用命令参考官方文档：https://redis.io/commands和 中文翻译版：http://redisdoc.com/https://www.redis.net.cn/order/3528.html redis为什么这么快1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)； 2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的； 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 4、使用多路I/O复用模型，非阻塞IO；只有IO这里是多线程，redis的业务均是多线程的。 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； 什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？雪崩、穿透、击穿雪崩定义：Redis 的 key 同时大面积失效，直接访问数据库，导致数据库压力解决: 处理缓存雪崩简单，在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效。 穿透定义：缓存中查不到，每次你去数据库里查，也查不到，请求每次都“视缓存于无物”，直接查询数据库。解决：1、在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return。2、每次系统 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。3、布隆过滤器（Bloom Filter）在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。 击穿指一个Key非常热点，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。解决：1、设置热点数据永远不过期。2、或者加上互斥锁就能搞定了，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。 避免以上情况事前事中事后的解决方案 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。 事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。 事后：redis 持久化RDB + AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。 三种集群方式主从复制Redis主从复制主要有两个角色，主机（master）对外提供读写功能，从机（slave）对外只提供读功能，主机定期把数据同步到从机上保证数据一致性。Redis主机数据同步到从机上有两种方式，一种是全量同步，另一种是增量同步。 主从同步你启动一台slave 的时候，他会发送一个sync命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成RDB快照，还会把新的写请求都缓存在内存中，RDB文件生成后，master会将这个RDB发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。 如果主节点发生故障怎么办？答：哨兵机制 哨兵机制（sentinel）功能： 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 一个健壮的部署至少需要三个哨兵实例 集群（cluster）redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。或者，当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中。 布隆过滤器优点：是空间效率和查询时间都远远超过一般的算法。缺点：是有一定的误识别率和删除困难。布隆过滤器检索时，使用相同的哈希函数进行计算出对应的bit位置，只要看这些位置的值，如果这些位置有任何一个0，则被检元素一定不在；如果都是1，则被检元素可能存在。一句话概率就是全0一定不存在、全1不一定存在。 布隆过滤器的误判是指多个输入经过哈希之后在相同的bit位置1了，这样就无法判断究竟是哪个输入产生的，因此误判的根源在于相同的bit位被多次映射且置1。这种情况也造成了布隆过滤器的删除问题，因为冲突的存在无法确定有多少输入映射到这个bit位了，当然这是个优化方向。 过期策略定期删除:默认100s就随机抽一些(而非全部)设置了过期时间的key，去检查是否过期，过期了就删了。但是，定期删除可能会导致很多过期key到了时间并没有被删除掉，所以就得靠惰性删除了。 惰性删除：等查询的时候再看看过期了没，过期了就删了不给返回。但是，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，怎么办？答：内存淘汰机制 内存淘汰机制当内存不足以容纳新写入数据时，有以下几个机制 noeviction：新写入操作会报错（这个一般没人用吧） allkeys-lru：在键空间中，移除最近最少使用的key（这个是最常用的） allkeys-random：在键空间中，随机移除某个key（这个一般没人用吧） volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适） volatile-random：在设置了过期时间的键空间中，随机移除某个key volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key优先移除 zset的底层实现原理跳表 参考文献面了BAT，我总结了他们会问的Redis基础知识阿里面试Redis最常问的三个问题：缓存雪崩、击穿、穿透大厂都喜欢这样问Redis，哨兵、持久化、主从、手撕LRU面了6家大厂，我把问烂了的Redis常见面试题总结了一下白话布隆过滤器BloomFilterRedis的过期策略和内存淘汰机制Redis|主从复制与哨兵机制Redis哨兵机制redis的三种集群方式","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"Java线程相关知识","slug":"thread","date":"2020-03-20T02:02:39.000Z","updated":"2020-10-13T14:17:02.418Z","comments":true,"path":"thread/","link":"","permalink":"http://yoursite.com/thread/","excerpt":"","text":"线程的状态 线程间通信方式 使用 volatile 关键字 使用Object类的wait() 和 notify() 方法（避免使用这个，尽量使用并发包下的信号同步类） 使用JUC工具类 CountDownLatch 使用JUC工具类CyclicBarrier循环屏障，是基于同步到达某个点的信号量触发机制。CyclicBarrier可以在构造时指定需要在屏障前执行await的个数。 使用 ReentrantLock 结合 Condition 基本LockSupport实现线程间的阻塞和唤醒 Java进阶（四）线程间通信剖析 创建线程的三种方式（待补充）线程池（待补充）常用方法join()可以将并行变为串行线程thread2中调用了thread1.join()，就进入等待状态 wait。直到 thread1 执行完毕后执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.liukai.thread.join;/** * @author liukai * @since 2019/6/7 16:05. */public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(new JoinA()); thread1.start(); Thread thread2 = new Thread(new JoinB(thread1)); thread2.start(); &#125;&#125;class JoinA implements Runnable &#123; @Override public void run() &#123; System.out.println(\"thread1 线程启动\"); for (int i = 0; i&lt; 2; i++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"thread1 -&gt; \" + i); &#125; &#125;&#125;class JoinB implements Runnable &#123; private Thread thread1; public JoinB(Thread thread1) &#123; this.thread1 = thread1; &#125; @Override public void run() &#123; try &#123; System.out.println(\"thread2 线程启动\"); System.out.println(\"thread2 调用 thread1.join 方法， 并等待 thread1 执行结束后执行\"); thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 2; i++) &#123; System.out.println(\"thread2 -&gt; \" + i); &#125; &#125;&#125; 打印内容为1234567thread1 线程启动thread2 线程启动thread2 调用 thread1.join 方法， 并等待 thread1 执行结束后执行thread1 -&gt; 0thread1 -&gt; 1thread2 -&gt; 0thread2 -&gt; 1 1.什么是线程基本概念 什么是叫一个进程？ 什么叫一个线程？ Program app -&gt;QQ.exe 进程：做一个简单的解释，你的硬盘上有一个简单的程序，这个程序叫QQ.exe，这是一个程序，这个程序是一个静态的概念，它被扔在硬盘上也没人理他，但是当你双击它，弹出一个界面输入账号密码登录进去了，OK，这个时候叫做一个进程。进程相对于程序来说它是一个动态的概念 线程：作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路径就叫做一个线程 示例：什么叫做线程 123456789101112131415161718192021222324252627282930313233package com.mashibing.juc.c_000;import java.util.concurrent.TimeUnit;public class T01_WhatIsThread &#123; private static class T1 extends Thread &#123; @Override public void run() &#123; for(int i=0; i&lt;10; i++) &#123; try &#123; TimeUnit.MICROSECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"T1\"); &#125; &#125; &#125; public static void main(String[] args) &#123; //new T1().run(); new T1().start(); for(int i=0; i&lt;10; i++) &#123; try &#123; TimeUnit.MICROSECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"main\"); &#125; &#125;&#125; 观察上面程序的数据结果，你会看到字符串“T1”和“Main”的交替输出，这就是程序中有两条不同的执行路径在交叉执行，这就是直观概念上的线程，概念性的东西，理解就好，没有必要咬文嚼字的去背文字的定义。 2.线程常用方法我们来认识几个线程的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.mashibing.juc.c_000;public class T03_Sleep_Yield_Join &#123; public static void main(String[] args) &#123; //testSleep(); //testYield(); testJoin(); &#125; /*Sleep,意思就是睡眠，当前线程暂停一段时间让给别的线程去运行。Sleep是怎么复活的？由你的睡眠时间而定，等睡眠到规定的时间自动复活*/ static void testSleep() &#123; new Thread(()-&gt;&#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(\"A\" + i); try &#123; Thread.sleep(500); //TimeUnit.Milliseconds.sleep(500) &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; /*Yield,就是当前线程正在执行的时候停止下来进入等待队列，回到等待队列里在系统的调度算法里头呢还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管*/ static void testYield() &#123; new Thread(()-&gt;&#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(\"A\" + i); if(i%10 == 0) Thread.yield(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(\"------------B\" + i); if(i%10 == 0) Thread.yield(); &#125; &#125;).start(); &#125; /*join， 意思就是在自己当前线程加入你调用Join的线程（），本线程等待。等调用的线程运行完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运行完毕继续t1运行（自己join自己没有意义） */ static void testJoin() &#123; Thread t1 = new Thread(()-&gt;&#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(\"A\" + i); try &#123; Thread.sleep(500); //TimeUnit.Milliseconds.sleep(500) &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(()-&gt;&#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for(int i=0; i&lt;100; i++) &#123; System.out.println(\"A\" + i); try &#123; Thread.sleep(500); //TimeUnit.Milliseconds.sleep(500) &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125; 3.启动线程的五种方式创建线程的几种方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.mashibing.juc.c_000;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.FutureTask;public class T02_HowToCreateThread &#123; static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"Hello MyThread!\"); &#125; &#125; static class MyRun implements Runnable &#123; @Override public void run() &#123; System.out.println(\"Hello MyRun!\"); &#125; &#125; static class MyCall implements Callable&lt;String&gt; &#123; @Override public String call() &#123; System.out.println(\"Hello MyCall\"); return \"success\"; &#125; &#125; //启动线程的5种方式 public static void main(String[] args) &#123; new MyThread().start(); new Thread(new MyRun()).start(); new Thread(()-&gt;&#123; System.out.println(\"Hello Lambda!\"); &#125;).start(); Thread t = new Thread(new FutureTask&lt;String&gt;(new MyCall())); t.start(); ExecutorService service = Executors.newCachedThreadPool(); service.execute(()-&gt;&#123; System.out.println(\"Hello ThreadPool\"); &#125;); service.shutdown(); &#125;&#125; 分享一道面试题 请你告诉我启动线程的三种方式 ?你说第一个：new Thread().start()； 第二个: new Thread(Runnable).start() 这没问题 ；那第三个呢，要回答线程池也是用的这两种之一，他这么问有些吹毛求疵的意思，你就可以说通过线程池也可以启动一个新的线程 3:Executors.newCachedThreadPool()或者FutureTask + Callable 4.线程同步的基本概念synchronized 下面我们来讲synchronized关键字，有不少同学已经耳熟能详了，不过作为复习还是要复习一下。第一个是多个线程去访问同一个资源的时候对这个资源上锁。 为什么要上锁呢？访问某一段代码或者某临界资源的时候是需要有一把锁的概念在这儿的。 比如：我们对一个数字做递增，两个程序对它一块儿来做递增，递增就是把一个程序往上加1啊，如果两个线程共同访问的时候，第一个线程一读它是0，然后把它加1，在自己线程内部内存里面算还没有写回去的时候而第二个线程读到了它还是0，加1在写回去，本来加了两次，但还是1，那么我们在对这个数字递增的过程当中就上把锁，就是说第一个线程对这个数字访问的时候是独占的，不允许别的线程来访问，不允许别的线程来对它计算，我必须加完1收释放锁，其他线程才能对它继续加。 实质上，这把锁并不是对数字进行锁定的， 你可以任意指定，想锁谁就锁谁。 我第一个小程序是这么写的 ，如果说你想上了把锁之后才能对count进行减减访问，你可以new一个Object，所以这里锁定就是o，当我拿到这把锁的时候才能执行这段代码。是锁定的某一个对象，synchronized有一个锁升级的概念，我们一会儿会讲到 1234567891011121314151617181920/***synchronized关键字*对某个对象加锁*@author mashibing*/package com.mashibing.juc.c_001;public class T &#123; private int count = 10; private Object o = new Object(); public void m() &#123; synchronized(o) &#123; //任何线程要想执行下面的代码，必须先拿到o的锁 count--; System.out.println(Thread.currentThread().getName() + \" count = \" + count); &#125; &#125; &#125; ​ 我们来谈一下synchronized它的一些特性。如果说你每次都定义个一个锁的对象Object o 把它new出来那加锁的时候太麻烦每次都要new一个新的对象出来，所以呢，有一个简单的方式就是synchronized(this)锁定当前对象就行 12345678910111213141516171819/** * synchronized关键字 * 对某个对象加锁 * @author mashibing */package com.mashibing.juc.c_002;public class T &#123; private int count = 10; public void m() &#123; synchronized(this) &#123; ߳//任何线程想要执行那个下面的代码，必须先要拿到this的锁 count--; System.out.println(Thread.currentThread().getName() + \" count = \" + count); &#125; &#125; &#125; 如果你要是锁定当前对象呢，你也可以写成如下方法。synchronized方法和synchronized(this)执行这段代码它是等值的 1234567891011package com.mashibing.juc.c_003;public class T &#123; private int count = 10; public synchronized void m() &#123; //等同于在方法的代码执行时要synchronized(this) count--; System.out.println(Thread.currentThread().getName() + \" count = \" + count); &#125;&#125; 我们知道静态方法static是没有this对象的，你不需要new出一个对象来就能执行这个方法，但如果这个这个上面加一个synchronized的话就代表synchronized(T.class)。这里这个synchronized(T.class)锁的就是T类的对象 1234567891011121314151617package com.mashibing.juc.c_004;public class T &#123; private static int count = 10; public synchronized static void m() &#123; //这里等同于synchronized(T.class) count--; System.out.println(Thread.currentThread().getName() + \" count = \" + count); &#125; public static void mm() &#123; synchronized(T.class) &#123; //考虑一下这里写synchronized(this)是否可以？ count --; &#125; &#125;&#125; 问题：T.class是单例的吗？ 一个class load到内存它是不是单例的，想想看。一般情况下是，如果是在同一个ClassLoader空间那它一定是。不是同一个类加载器就不是了，不同的类加载器互相之间也不能访问。所以说你能访问它，那他一定就是单例 下面程序：很有可能读不到别的线程修改过的内容，除了这点之外count减减完了之后下面的count输出和你减完的结果不对，很容易分析：如果有一个线程把它从10减到9了，然后又有一个线程在前面一个线程还没有输出呢进来了把9又减到了8，继续输出的8，而不是9。如果你想修正它，前面第一个是在上面加volatile，改了马上就能得到。 1234567891011121314151617181920212223/** * 分析一下这个程序的输出 * @author mashibing */package com.mashibing.juc.c_005;public class T implements Runnable &#123; private /*volatile*/ int count = 100; public /*synchronized*/ void run() &#123; count--; System.out.println(Thread.currentThread().getName() + \" count = \" + count); &#125; public static void main(String[] args) &#123; T t = new T(); for(int i=0; i&lt;100; i++) &#123; new Thread(t, \"THREAD\" + i).start(); &#125; &#125; &#125; 另外这个之外还可以加synchronized，加了synchronized就没有必要在加volatile了，因为synchronized既保证了原子性，又保证了可见性。 1234567891011121314151617181920//对比上一个小程序package com.mashibing.juc.c_006;public class T implements Runnable &#123; private int count = 10; public synchronized void run() &#123; count--; System.out.println(Thread.currentThread().getName() + \" count = \" + count); &#125; public static void main(String[] args) &#123; for(int i=0; i&lt;5; i++) &#123; T t = new T(); new Thread(t, \"THREAD\" + i).start(); &#125; &#125; &#125; 如下代码：同步方法和非同步方法是否可以同时调用？就是我有一个synchronized的m1方法，我调用m1的时候能不能调用m2，拿大腿想一想这个是肯定可以的，线程里面访问m1的时候需要加锁，可是访问m2的时候我又不需要加锁，所以允许执行m2。 这些小实验的设计是比较考验功力的，学习线程的时候自己要多动手进行试验，任何一个理论，都可以进行验证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** *同步和非同步方法是否可以同时调用？ * @author mashibing */package com.mashibing.juc.c_007;public class T &#123; public synchronized void m1() &#123; System.out.println(Thread.currentThread().getName() + \" m1 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m1 end\"); &#125; public void m2() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m2 \"); &#125; public static void main(String[] args) &#123; T t = new T(); /*new Thread(()-&gt;t.m1(), \"t1\").start(); new Thread(()-&gt;t.m2(), \"t2\").start();*/ new Thread(t::m1, \"t1\").start(); new Thread(t::m2, \"t2\").start(); /* //1.8之前的写法 new Thread(new Runnable() &#123; @Override public void run() &#123; t.m1(); &#125; &#125;); */ &#125;&#125; 我们在来看一个synchronized应用的例子 我们定义了一个class账户，有名称、余额。写方法给哪个用户设置它多少余额，读方法通过这个名字得到余额值。如果我们给写方法加锁，给读方法不加锁，你的业务允许产生这种问题吗？业务说我中间读到了一些不太好的数据也没关系，如果不允许客户读到中间不好的数据那这个就有问题。正因为我们加了锁的方法和不加锁的方法可以同时运行。 问题比如说：张三，给他设置100块钱启动了，睡了1毫秒之后呢去读它的值，然后再睡2秒再去读它的值这个时候你会看到读到的值有问题，原因是在设定的过程中this.name你中间睡了一下，这个过程当中我模拟了一个线程来读，这个时候调用的是getBalance方法，而调用这个方法的时候是不用加锁的，所以说我不需要等你整个过程执行完就可以读到你中间结果产生的内存，这个现象就叫做脏读。这问题的产生就是synchronized方法和非synchronized方法是同时运行的。解决就是把getBalance加上synchronized就可以了，如果你的业务允许脏读，就可以不用加锁，加锁之后的效率低下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 面试题：模拟银行账户 * 对业务写方法加锁 * 对业务读方法不加锁 * 这样行不行？ * * 容易产生脏读问题（dirtyRead） */package com.mashibing.juc.c_008;import java.util.concurrent.TimeUnit;public class Account &#123; String name; double balance; public synchronized void set(String name, double balance) &#123; this.name = name; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.balance = balance; &#125; public /*synchronized*/ double getBalance(String name) &#123; return this.balance; &#125; public static void main(String[] args) &#123; Account a = new Account(); new Thread(()-&gt;a.set(\"zhangsan\", 100.0)).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(a.getBalance(\"zhangsan\")); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(a.getBalance(\"zhangsan\")); &#125;&#125; 再来看synchronized的另外一个属性：可重入，是synchronized必须了解的一个概念。 如果是一个同步方法调用另外一个同步方法，有一个方法加了锁，另外一个方法也需要加锁，加的是同一把锁也是同一个线程，那这个时候申请仍然会得到该对象的锁。比如说是synchronized可重入的，有一个方法m1 是synchronized有一个方法m2也是synchrionzed，m1里能不能调m2。我们m1开始的时候这个线程得到了这把锁，然后在m1里面调用m2，如果说这个时候不允许任何线程再来拿这把锁的时候就死锁了。这个时候调m2它发现是同一个线程，因为你m2也需要申请这把锁，它发现是同一个线程申请的这把锁，允许，可以没问题，这就叫可重入锁。 1234567891011121314151617181920212223242526272829303132333435/** * 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。 * 也就是说synchronized获得锁是可重入的 * synchronized * @author mashibing */package com.mashibing.juc.c_009;import java.util.concurrent.TimeUnit;public class T &#123; synchronized void m1() &#123; System.out.println(\"m1 start\"); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; m2(); System.out.println(\"m1 end\"); &#125; synchronized void m2() &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"m2\"); &#125; public static void main(String[] args) &#123; new T().m1(); &#125;&#125; 模拟一个父类子类的概念，父类synchronized，子类调用super.m的时候必须得可重入，否则就会出问题（调用父类是同一把锁）。所谓的重入锁就是你拿到这把锁之后不停加锁加锁，加好几道，但锁定的还是同一个对象，去一道就减个1，就是这么个概念。 12345678910111213141516171819202122232425262728package com.mashibing.juc.c_010;import java.util.concurrent.TimeUnit;public class T &#123; synchronized void m() &#123; System.out.println(\"m start\"); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"m end\"); &#125; public static void main(String[] args) &#123; new TT().m(); &#125;&#125;class TT extends T &#123; @Override synchronized void m() &#123; System.out.println(\"child m start\"); super.m(); System.out.println(\"child m end\"); &#125;&#125;","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"测试工具","slug":"pressure-measurement","date":"2020-03-11T04:07:12.000Z","updated":"2020-10-13T14:13:17.423Z","comments":true,"path":"pressure-measurement/","link":"","permalink":"http://yoursite.com/pressure-measurement/","excerpt":"","text":"Apache Bench系统环境Win10注意：不要在云服务器上跑，因为压力测试工具也会占据一部分资源。所以我在本地电脑上测试。 压测工具apache bench简称ab,它是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等。 下载http://httpd.apache.org/ 解压后无需安装 启动12cd D:\\develop\\Java\\(压测)httpd-2.4.41-o111c-x64-vc15-r2\\Apache24\\binab -n 1000 -c 100 http://39.97.122.3:8080/ 其中－n表示请求数，－c表示并发数 结果12345678910111213141516171819202122232425262728293031323334353637383940414243D:\\develop\\Java\\(压测)httpd-2.4.41-o111c-x64-vc15-r2\\Apache24\\bin&gt;ab -n 100 -c 10 http://39.97.122.3:8080/This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking 39.97.122.3 (be patient).....doneServer Software: Apache-Coyote/1.1Server Hostname: 39.97.122.3Server Port: 8080Document Path: /Document Length: 20425 bytesConcurrency Level: 10Time taken for tests: 2.364 secondsComplete requests: 100Failed requests: 0Total transferred: 2059100 bytesHTML transferred: 2042500 bytesRequests per second: 42.31 [#/sec] (mean)Time per request: 236.359 [ms] (mean)Time per request: 23.636 [ms] (mean, across all concurrent requests)Transfer rate: 850.76 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 11 16 2.9 16 30Processing: 34 188 135.5 146 861Waiting: 14 66 39.7 62 272Total: 47 204 135.9 162 880Percentage of the requests served within a certain time (ms) 50% 162 66% 168 75% 176 80% 299 90% 361 95% 404 98% 822 99% 880 100% 880 (longest request) 性能指标 吞吐率（Requests per second）概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。计算公式：总请求数 / 处理完成这些请求数所花费的时间，即Request per second = Complete requests/ Time taken for tests 并发连接数（The number of concurrent connections）概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。 并发用户数（The number of concurrent users，Concurrency Level）概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。 用户平均请求等待时间（Time per request） 计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即Time per request = Time taken for tests /（ Complete requests /Concurrency Level） 服务器平均请求等待时间（Time per request: across all concurrent requests）计算公式：处理完成所有请求数所花费的时间 / 总请求数，即Time taken for / testsComplete requests可以看到，它是吞吐率的倒数。 同时，它也=用户平均请求等待时间/并发用户数，即Time per request / Concurrency Level 分析下面为几个比较关心的指标 Requests per second: 42.31 [#/sec] (mean)//吞吐率，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值 Time per request: 236.359 [ms] (mean)//用户平均请求等待时间，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值 Time per request: 23.636 [ms] (mean, across all concurrent requests)//服务器平均请求处理时间 Percentage of the requests served within a certain time (ms)这段是每个请求处理时间的分布情况，50%的处理时间在162ms内，90%的处理时间在361ms内…，重要的是看90%的处理时间。 Apache JMeter压测结果线程组参数含义记录线程组分别为以下几种时的性能50-1-100 时服务器崩溃 参考文献https://www.cnblogs.com/behindman/p/8700611.htmlhttps://blog.csdn.net/qq_34252622/article/details/92431267","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"Java中的锁","slug":"lock","date":"2020-03-04T09:17:21.000Z","updated":"2020-05-21T08:48:23.830Z","comments":true,"path":"lock/","link":"","permalink":"http://yoursite.com/lock/","excerpt":"","text":"CAS AQSCAS线程在读取数据时不进行加锁，在准备写回数据时，先去查询原值，操作的时候比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。 三要素：内存地址、旧的预期值、要修改的新值 存在的问题：1.ABA问题。解决办法：对内存中的值加个版本号，在比较的时候除了比较值还的比较版本号。2.CPU开销较大在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。3.不能保证代码块的原子性CAS机制所保证的只是一个变量的原子性操作，CAS分两步：①判断这个变量是否没有变，②如果没有变，则进行写入操作。为了保证在执行完①之后，不被打断地继续执行②，这是一个原子性操作，由CPU底层实现:lock cmpxchg（注；Synchronized 内部也是由这条命令实现）。而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。 AQS在AQS中，定义了一个volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步FIFO队列等待；如果成功获取资源就执行临界区代码。执行完释放资源时，会通知同步队列中的等待线程来获取资源后出队并执行。AQS的底层操作时通过CAS实现。深入分析AQS实现原理 JAVA锁有哪些种类，以及区别公平锁/非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。 可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。 可重入锁的实现原理: 是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为0，当被线程占用和重入时分别加1，当锁被释放时计数器减1，直到减到0时表示此锁为空闲状态。 独享锁/共享锁独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。 对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。对于Synchronized而言，当然是独享锁。 互斥锁/读写锁上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是ReentrantLock读写锁在Java中的具体实现就是ReadWriteLock 乐观锁/悲观锁乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。 需要结合这两种锁的特点，进行合理的选择: 响应速度：选择乐观锁。要么冲突失败要么快速成功。悲观锁则需要等待释放锁才能被执行 冲突频率：频率高的话不应选择乐观锁，需要重试好几次，代价大。而悲观锁保证成功率 重试代价：若重试代价大则选择悲观锁 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。 悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。 注意：乐观锁不会造成死锁。 分段锁分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 无锁/偏向锁/轻量级锁/重量级锁 对象头中有一项重要的部分：Markworld。如下图所示这四种锁是指锁的状态，并且是针对Synchronized。Synchronized早期是重量级锁，后来在Java JDK5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。无锁：最开始new出来，是没有锁的。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。偏向锁是默认4秒之后启动，这四秒干了啥事：它要看有多少线程竞争，如果有竞争，那就没有偏向锁了，直接到轻量级。轻量级锁（自旋锁，是CAS实现的）是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候（10次），还没有获取到锁，或者 等待的线程超过核心数的1/2，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。重量级锁不消耗CPU资源，它维持了一个等待队列。 什么情况下，轻量级锁升级为重量级锁？1.6之前，有线程自旋超过10次 或者 自旋线程数超过CPU核心数的一半。后来做了1.6优化：引入 自适应自旋。 偏向锁可以不经过，是必须经过自旋锁才到重量锁吗？不是必须自旋。如果调用wait，就直接重量锁。 自旋锁在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。 synchronized 与 lock 的区别 synchronized是java的内置关键字，在JVM层面； Lock是个java类 synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁 synchronized会自动释放锁（线程执行完同步代码会释放或发生异常会释放）；Lock需要在finally中手动释放锁（unlock()释放锁），否则容易造成线程死锁 使用synchronized时，等待的线程会一直等待下去，不能够中断，程序员无法控制；Lock可以让等待锁的线程响应中断处理，如tryLock(long time, TimeUnit unit) synchronized的锁可重入，不可中断，非公平。而Lock锁可重入，可中断，可公平 synchronized可以锁住代码块、对象实例、类；Lock锁的范围有局限性，仅适用于代码块范围 synchronized要么随机唤醒一个，要么唤醒全部线程；Lock可以绑定条件，实现分组唤醒需要的线程 死锁产生的必要条件 互斥条件：一个资源每次只能被一个进程使用。即当资源被一个线程使用(占有)时，别的线程不能使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。即资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。 避免死锁的几个常见方法 避免一个线程同时获取多个锁。 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。 如果没有加锁，怎么确保数据一致性用AtomicInteger 参考文献JAVA锁有哪些种类，以及区别Java面试准备-锁机制并发编程网|Java锁的种类以及辨析关于死锁面试题深入分析AQS实现原理","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"二叉树","slug":"erchashu","date":"2020-02-26T13:43:03.000Z","updated":"2020-04-12T04:20:00.349Z","comments":true,"path":"erchashu/","link":"","permalink":"http://yoursite.com/erchashu/","excerpt":"","text":"二叉树四种遍历（递归和非递归代码实现）前序遍历（根-&gt;左-&gt;右）若树为空，则空操作返回。否则，先访问根节点，然后前序遍历左子树，再前序遍历右子树。（根-&gt;左-&gt;右）。 中序遍历（左-&gt;根-&gt;右）若树为空，则空操作返回。否则，从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历根节点的右子树。（左-&gt;根-&gt;右）。 后序遍历（左-&gt;右-&gt;根）若树为空，则空操作返回。否则，从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点。（左-&gt;右-&gt;根）。 层序遍历若树为空，则空操作返回。否则，从树的第一层，也就是根节点开始访问，从上到下逐层遍历，在同一层中，按从左到右的顺序结点逐个访问。 参考文献二叉树的四种遍历（递归和非递归）–Java实现二叉树的四种遍历方式【Java实现】 树的分类二叉树每个节点至多有两个节点的树 二叉搜索树/查找树/排序树（BST）特点：每个节点的值大于其任意左侧子节点的值，小于其任意右节点的值。 二叉平衡树树的左右高度差不能超过1；任何往下递归的左子树与右子树满足第一条；没有任何节点的空树或只有根节点的树也是平衡树。 平衡二叉搜索树是一种特殊情况下的二叉查找树，它的特殊之处在于，对于每一个节点，其左子树深度和右子树深度之差的绝对值不大于1。最早被发明的平衡二叉搜索树为AVL树。 红黑树红黑树本质是二叉搜索树，还有5个约束(1) 节点只能只红色或者黑色（红黑树嘛，就是说只有这俩个颜色）(2) 根节点必须为黑色(3) 所有NIL节点是黑色（Nothing In leaf，是红黑树中特殊的存在，即叶子节点上不存在的两个虚拟节点，是后续红黑树旋转的基础）(4) 一条路径上不能出现相邻的两个红色节点(5) 在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色节点红黑树的时间复杂度为: O(lgn)，n为节点个数。 满二叉树一棵深度为k且有2^k-1个结点的二叉树称为满二叉树。 完全二叉树除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。 B+树b-","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"JVM垃圾回收机制","slug":"GC","date":"2020-02-26T05:59:16.000Z","updated":"2020-05-13T22:43:55.637Z","comments":true,"path":"GC/","link":"","permalink":"http://yoursite.com/GC/","excerpt":"","text":"1 哪些内存需要回收？引用计数法在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 可达性分析算法（重点）以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： 在虚拟机栈（栈帧中的本地变量表）中引用的对象 在方法区中类静态属性引用的对象 在方法区中常量引用的对象， 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 强引用、软引用、弱引用和虚引用。强度递减。 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。 2 什么时候回收？堆的新生代、老年代、永久代的垃圾回收时机，MinorGC （[ˈmaɪnə(r)]）和 FullGC触发时机 新生代、老年代、永久代 新生代（Young Generation），目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。 老年代（Old Generation），放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。 永久代（Permanent Generation），主要用于存放静态文件，如Java类、方法等。 内存分配策略对象优先在Eden（[ˈiːdn]）分配大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 大对象直接进入老年代大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。大对象对虚拟机的内存分配来说 就是一个不折不扣的坏消息，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对 象”，我们写程序的时候应注意避免。在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复 制对象时，大对象就意味着高额的内存复制开销。HotSpot虚拟机提供了-XX：PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区 之间来回复制，产生大量的内存复制操作。 长期存活的对象将进入老年代HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。为做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中（详见第2章）。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（PS,PO,G1默认为15（也是最大的，因为这是一个四位的二进制数）；CMS默认为6），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX： MaxTenuringThreshold设置。 动态对象年龄判定为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor（[səˈvaɪvə(r)]）空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX： MaxTenuringThreshold中要求的年龄。 空间分配担保在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX： HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。解释一下“冒险”是冒了什么风险：前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况 ——最极端的情况就是内存回收后新生代中所有对象都存活，需要老年代进行分配担保，把Survivor无 法容纳的对象直接送入老年代，这与生活中贷款担保类似。老年代要进行这样的担保，前提是老年代 本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之 前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与 老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。 分类 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。 Minor GC 触发条件非常简单。当Eden区满时，触发Minor GC。 Survivor满不会引发GC。 Full GC 触发条件示例 调用 System.gc()只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。 JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 3 如何回收？三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器 垃圾收集算法标记-清除算法首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程主要缺点：第一个是执行效率不稳定。标记和清除过程的执行效率随对象数量增长而降低；第二个是内存空间的碎片化问题。可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作 标记-复制算法（简称复制算法）回收新生代Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的 Survivor空间（Eden：Survivor = 8：1），每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍 然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间 标记-整理算法 回收老年代其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存 分代收集 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 垃圾收集器Serial收集器（复制算法)新生代单线程收集器，标记和清理都是单线程，优点是简单高效； Serial Old收集器 (标记-整理算法)老年代单线程收集器，Serial收集器的老年代版本； ParNew收集器 (复制算法)新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现； Parallel Scavenge收集器 (复制算法)新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； Parallel Old收集器 (标记-整理算法)老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本； CMS(Concurrent Mark Sweep)收集器（标记-清除算法）老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。 G1(Garbage First)收集器 (标记-整理算法)Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。 4 OutOfMemoryError异常（OOM）Java堆溢出Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会 产生内存溢出异常。 虚拟机栈和本地方法栈溢出由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置 本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟 机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常：1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。 《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。 单线程时，无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候， HotSpot虚拟机抛出的都是StackOverflowError异常。可是如果在允许动态扩展栈容量大小的虚拟机 上，相同代码则会导致不一样的情况。譬如远古时代的Classic虚拟机，这款虚拟机可以支持动态扩展栈内存的容量，会成功产生了OutOfMemoryError而不是StackOver-flowError异常。 多线程时，如果测试时不限于单线程，通过不断建立线程的方式，在HotSpot上也是可以产生内存溢出异常的。但是这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关 系，主要取决于操作系统本身的内存使用状态。甚至可以说，在这种情况下，给每个线程的栈分配的 内存越大，反而越容易产生内存溢出异常。 方法区和运行时常量池溢出（运行时常量池是方法区的一部分） String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加 到常量池中，并且返回此String对象的引用。在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过-XX：PermSize和-XX：MaxPermSize限制永久代的大小，即可间接限制其中常量池的容量。而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，，是因为自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中，所以在JDK 7及以上版 本，限制方法区的容量对该测试用例来说是毫无意义的。这时候使用-Xmx参数限制最大堆的大小就能出现OOM。 方法区的其他部分，在JDK1.7及以前，有永久代概念，如果动态加载类过多，容易产生永久代的OOM。 本机直接内存溢出内存不足，也会抛出OOM。","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"如何部署一个SpringBoot项目实现线上访问","slug":"deploy","date":"2020-02-21T12:01:56.000Z","updated":"2020-04-23T03:01:15.404Z","comments":true,"path":"deploy/","link":"","permalink":"http://yoursite.com/deploy/","excerpt":"","text":"1、项目入口中，实现接口12345678910111213@SpringBootApplicationpublic class Application extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Application.class); //Application对应class名称 &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 2、在pom.xml中添加一行123&lt;packaging&gt;war&lt;/packaging&gt;或&lt;packaging&gt;jar&lt;/packaging&gt; 3、把项目中的其他测试的所有main函数更名或者注释，保证项目只有一个入口。 4、cmd到工程目录下 12mvn clean //清除了target目录mvn package -Dmaven.test.skip=true 注：报错，xxx包不存在的解决：找到指定的文件下，检查下 import中是否有灰色的，应该是不小心导错了无用且不存在的包，删除即可。 5、cmd到target目录下1java -jar xxx.jar 在8080端口下就可以打开了 注：4和5两步骤也可以在IDEA里，对应”clean” “package” 6、在阿里云Linux服务器上部署。安装JDK后。1nohup java -jar wenda.jar &gt; temp.txt 2&gt;&amp;1 &amp; 7、如果重新上传显示当前终端开的后台任务。 [xxx]为PID1jobs -l 终端已经关闭，找到 java -jar wenda.jar 的PID1ps ux 关闭PID1kill -9 PID 域名的配置安装好 nginx 后1、 查看nginx安装目录，并进入nginx.conf文件中ps -ef | grep nginx 参考文献：官方教程|导出一个可部署的War文件","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"剑指Offer解题思路","slug":"nowcoder","date":"2020-02-18T09:04:22.000Z","updated":"2020-05-13T10:31:59.065Z","comments":true,"path":"nowcoder/","link":"","permalink":"http://yoursite.com/nowcoder/","excerpt":"","text":"答 ：说明此题有疑问答 ：代表此题解法与参考文献不同 3 数组中重复的数字问：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 答：注意范围是0~n-1，所以利用下标。for循环遍历下标，while将遍历到的这个值swap到该放的位置上,一直等i的值是匹配（while条件）的才跳出来while;在while中，每次要if先判断下目标移动位置上的值是否已经存在，存在那就是找到重复的。方法默认的false，假设有一个重复了，导致0没有了，意味着遍历完所有的了都没有找到，那肯定的法拉瑟了。注：numbers == null || length &lt;= 0 是首先验证条件，直接返回false 4 二维数组的查找问：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 答：从右上角（或者左下角）开始while遍历，判断值的大小来i++，或者j–; 5 替换空格问：将一个字符串中的空格替换成 “%20” 答：分两步骤： 找空格，加在尾部；指针移动替换1、因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。2、令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历。3、当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。4、只有当P2 &gt; P1 &amp;&amp; P1 &gt;= 0 才进行上述步骤。注：在步骤1中，遍历的条件只能是 i&lt;= p1; 不能用i &lt; str.length() 因为str长度在变！str.charAt(i) == ‘ ‘ //charAt(i) 和 str.setCharAt(i,’x’) 都是单引号；String要获取某下标的元素得用charAt，区别于数组的a[i]。str.append(“ “) //str.append(String s) 双引号str.toString() //将StringBuffer 转换成String 6 从尾到头打印链表问：输入一个链表，按链表从尾到头的顺序返回一个ArrayList答： 堆栈法栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。注：import java.util.Stack; //导包，自己手动加的listNode.val //获取listNode当前的值listNode = listNode.next; //下一个节点listNode != null //是否遍历完了 递归法 7 重建二叉树（难）问：根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。答：前序遍历序列的第一个元素 1 就是二叉树的根节点，中序遍历序列的根节点 1 把这个序列分成两半部分，分别是[4,7,2]和[5,3,8,6]，左半分部是根节点的左子树，右半分布是根节点的右子树。基于这个特点，我们可以采用递归的方法来做，其大致逻辑如下。1、通过前序序列第一个元素确定根节点(例如 1)。2、通过根节点把中序序列分成两个序列，一个是左子树序列([4,7,2)]，一个是右子树序列([5,3,8,6)]。3、通过左右子树的中序序列可以求出前序遍历的左右子树序列(左:[2,4,7],右:[3,5,8,6])。4、左右子树的前序序列第一个元素分别是根节点的左右儿子。 8 二叉树的下一个结点(空，树)9 用两个栈实现队列问：用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。答：push: 只push就行pop: 总是返回2的pop。如果2为空，就将1的全部pop到1里面。先判断2是否为空，抛异常。最后return 是stack2.pop()；注意：2为空时，注意pop异常 public int pop() throws Exception{ throw new Exception(“queue is empty”);} //前面throw有s，后面没有s. 10.1 斐波那契数列问：现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39答：因为n限制了范围，用最基础的大小为40的数组来保存，不用递归了。 10.2 矩形覆盖问：我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 答：如果使用2x1的矩形来覆盖2x8的矩形的话，设有f(n)中覆盖放法。首先，第一个2x1的矩形有两种放法，第一种，竖着放，剩下的部分有f(7)种，第二种横着放，剩下的部分有f(6)种。则一共有f(8) = f(7) + f(6)。很明显这又是著名的Fibonacci数列。但是不要用递归，因为时间复杂度太大；用循环好处是，数列中间项保存起来，一直到求到了目标n。注：pre2 = pre1; pre1 = result; 注意先后顺序，以免pre1被覆盖了。 10.3 跳台阶问：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。答：跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。又是斐波那契数列，算法同上一模一样，也是避免用递归。 10.4 变态跳台阶问：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。答：f(n)=2f(n-1) 等比数列 f(n) = 2的(n-1)次方 11 旋转数组的最小数字问：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。答：（1）array[mid] &gt; array[high];出现这种情况array类似[3, 4, 5, 0, 1, 2],此时最小数字移动在mid的右边。low = mid + 1；（2）array[mid] == array[high]出现这种情况array类似[0, 1, 1, 1, 1,]或者[1, 1, 1, 0, 1],此时最小数字不好判断在mid左边还是右边，这个时候只能一个个的试high = high - 1;（3）array[mid] &lt; array[high]:出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。high = mid 12 矩阵中的路径（空。回溯法）13 机器人的运动范围（空。回溯法）14 剪绳子问：给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。答：（贪心法）尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。证明：当 n &gt;= 5 时，3(n - 3) - n = 2n - 9 &gt; 0，且 2(n - 2) - n = n - 4 &gt; 0。因此在 n &gt;= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) = n - 5 &gt;= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。所以先判断 n 的值 n&lt;2 reutrn 0; n==2 reutrn 1; n==3 reutrn 2; 其余的值按照所提的贪心算法（包括4） 15 二进制中 1 的个数位运算有5种，与（&amp;），或（|），异或（^），左移（&lt;&lt;最左边的n位丢弃，后面补0），右移（&gt;&gt;稍微复杂，需要判断第一位。如果，无符号数值，用0填补左边；如果有符号数值，用第一位的数填补。）问：输入一个整数，输出该数二进制表示中 1 的个数。答：1、把一个整数减去1，会使得最右边的1变成0，并且后面的0全部变成1。再和原整数做与运算，就会使得原整数的最右边的1变为0，计数器+12、再将得到的这个数重复上述操作，只要这个数不为03、返回计数器的数 16 数值的整数次方问：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。（实现pow方法）答：这个题目不难，关键在于exponent的边界，0（return）；1(return)；和负数都要分析，用一个isNegative = true,来表示负数,并且将exponent = -exponent;，最后return isNegative?/1pow:pow因为 (x)^(n/2) 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。 17 打印从 1 到最大的 n 位数（空。回溯法）18.1 删除链表的节点问：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。（链接题目略有改动）答：首先进行是否为null的判断。判断这个节点是不是最后一个节点。也就是tobeDelete.next == null。如果该节点不是尾节点，比如 h-&gt;i-&gt;j-&gt;?，如果想删除i。按照传统思路，从头节点开始遍历，找到指向节点i的节点（也就是h），将h指向j即可，但是需要顺序查找，复杂度为O(n)。换个思路，既然j不为null，也就是j后面还指向了别的，那可以删除j，是等效删除了i。具体做法，将j节点的值赋给i节点上，并且让i节点指向j的下一个节点。这样就不用遍历来找指向i的节点了。复杂度是O(1)。如果该节点是尾节点，要分两种情况，1、链表只有一个节点，也就是 head == tobeDelete，删除后就什么都没了，head=null; 2、一直while找到尾部，条件为cur.next != tobeDelete 18.2 删除链表中重复的结点问：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5答：1、非null判断。如果 pHead == null || pHead.next == null，return2、如果 pHead.val == next.val，说明重复，但可能多个连续重复，所以要while，一直找到不重复的。 while(pHead.val == next.val)，空指针没有值，会报错，所以while条件要加上next != null3、如果不满足2，那就简单了，顺延head，检查下一个即可。 19 正则表达式匹配（空）问：请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配答： 20 表示数值的字符串问：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。答：[] ： 字符集合() ： 分组? ： 重复 0 ~ 1 次+ ： 重复 1 ~ n 次* ： 重复 0 ~ n 次. ： 任意字符\\\\. ： 转义后的 .\\\\d ： 数字 1、首先进行非null判断2、(A)(B)(C) 三部分组成A：整数。整体有没有都行。正负号：有没有都行。数字部分：有没有都行（.2是合法的），所以是0~n。B：小数。整体有没有都行。点. 数字部分：不能没有数字（3. 是不合法的）1~nC：指数。整体有没有都行。Ee:必须有。正负号：有没有都行。数字部分：1~n注:String str = new String(charArray); //将一个char类型的数组，转换成字符串str.matches(“ “); //参数为正则表达式，是否匹配，返回值为布尔型 21 调整数组顺序使奇数位于偶数前面问：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。答：创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。1、找出奇数的个数 oddCount2、int[] copy = array.clone(); int i = 0; int j = oddCount; 遍历copy里的元素分类奇数和偶数，覆盖array里的元素，i++或者j++注意：.clone() 方法：创建并返回此对象的副本。 22 链表中倒数第 K 个结点问：输入一个链表，输出该链表中倒数第k个结点。答：双指针1、head非空判断2、设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点3、此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 倒数第K个节点处。注意：还应该进行k的值不大于链表的长度，但由于无法像数组那样获取链表的长度，所以在第二步骤中，while(p1!=null &amp;&amp; k&gt;0) ,等while结束后，判断k&gt;0就返回false。这样一来第一步可以省掉了 23 链表中环的入口结点问：一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。答：双指针，快慢指针。思路更简洁，代码同CyC。两个指针fast和slow，fast以slow两倍速度前进，如果没有环，那么fast和slow不会相遇此时返回null；如果有环，那fast和slow肯定会再次相遇.相遇的时候，fast刚好比slow多走了一圈环的长度。用图来描述下，当fast与slow相遇时，fast走过的距离为a + b + c + b，而slow走过的距离为a + b，因为fast是slow速度的两倍，则有a+b+c+b = 2*(a+b)，得出a=c;此时第三个指针p从x处，以和slow指针相同的速度前进，当它两相遇时，即为环的起点Y处！这一步就没有快指针的事情了，所以可以让fast来行使p的作用，注意每次移动一格。 1、非null判断 pHead == null || pHead.next == null 。2、do{}while(); //用这个结构的循环，因为第一步的时候 fast = slow = pHead; 如果用while，就不通过了。3、相遇后，两个慢指针，while 24 反转链表与第六题类似，从尾到头打印链表问：输入一个链表，反转链表后，输出新链表的表头。答： 堆栈法 25 合并两个排序的链表问：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。答：1、非null判断2、新建一个空链表 ListNode listAll = null; 等效于 ListNode newlist = new ListNode(-1);2、合并过程中，首先比较两个链表的首节点哪个小，较小的节点作为新链表的首节点3、这一步是递归过程。新链表的下一个节点就一直是比较 第二步较小节点的下一个 与 第二步较大节点。再次进行上面逻辑的比较。 26 树的子结构问：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）答： 递归法1、写两个函数，主函数HasSubtree, 用到递归。return isSubtreeWithRoot(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);2、功能函数 isSubtreeWithRoot ，判断下以这个为根节点，是不是相同的。第一步如果root2为空，return true;第二步如果root1 为空（第一步没进入if,隐含root2不为空），return false;第三步，判断下根节点值是否相等，不相等，也就不用判断下面的子节点了，直接return false。最后用到递归判断下左右子节点的情况，子节点又可以看作新的root。return isSubtreeWithRoot(root1.left, root2.left) &amp;&amp; isSubtreeWithRoot(root1.right, root2.right); 27 二叉树的镜像问：操作给定的二叉树，将其变换为源二叉树的镜像。答：1、定义一个功能函数，输入一个根节点，将他的左右叶子换换。 swap()2、主函数Mirror 用递归。一个树如果为空，直接return; 否则执行 swap(root);swap(root.left);swap(root.right); 28 对称的二叉树问：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。我们规定一个空二叉树是对称的。答：1、写功能函数，给两个节点root1,root2，判断是否对称。如果两个节点同时都为空，返回true;如果两个节点有一个为空，返回true。接下来的情况就是两个节点都不为空，那先判断下节点的值是否相等，不相等直接return false。最后递归调用本函数判断 root1左叶子与 root2右叶子 并且 root1右叶子与root2左叶子。2、写主函数，调用功能函数就行。注：节点的值为 root.val 29 顺时针打印矩阵问：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 注意矩阵，不一定是正方形，所以每一次的逼近后，都要判断答：不断地收缩矩阵的边界定义四个变量代表范围，up、down、left、right1、向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错2、向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错3、向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错4、向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错 30 包含 min 函数的栈问：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。 答：题目只让定义min()可以利用Stack的已有方法boolean empty()； // 测试此堆栈是否为空。E peek(); // 查看此堆栈顶部的对象，而不从堆栈中删除它。E pop(); // 删除此堆栈顶部的对象，并将该对象作为此函数的值返回。E push(E item); // 将对象推送到此堆栈的顶部。 定义两个空栈dataStack 和 minStack（辅助），在push方法执行的时候，dataStack照单全收；minStack每次也会收一个，但是注意如果小就收小的，否则就重复一个minStack顶上的值，这样的目的是如果执行POP，可以帮下面小的抗一下，又可以保证这个确实是dataStack中的最小值。妙哉！public void push(int node) { dataStack.push(node); minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));} 31 栈的压入、弹出序列（空。没读懂题目）32.1 从上往下打印二叉树问：从上往下打印出二叉树的每个节点，同层节点从左至右打印。答：用队列 LinkedList实现了List 和 Deque 接口，具有先进先出的特性。将树的节点作为元素放入队列中。用ArrayList 来放遍历打印的结果。LinkedList 方法boolean offer(E e) // 将指定的元素添加为此列表的尾部（最后一个元素）。E poll() // 检索并删除此列表的头（第一个元素）。 1、非null判断2、加入root节点到队列中3、while(!queue.isEmpty){int count = queue.size();while(count–&gt;0){取出来队列的一个节点，将值放入ArrayList分别判断这个节点的左右叶子是否为空，如果不为空，加入队列}}注意：导入import java.util.LinkedList; 32.2 把二叉树打印成多行问：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。答：和上题不同之处在于，ArrayList&lt;ArrayList&gt; ret = new ArrayList&lt;&gt;();并在内部那个while结束之后，将ArrayList list 放入 ret。 32.3 按之字形顺序打印二叉树问：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推答：和上一个题的不同之处在于，要定义一个boolean isReverse = false;在内部那个while结束后，判断下 isReversestatic void Collections.reverse(List&lt;?&gt; list) // 反转指定列表中元素的顺序。在原来list基础上修改的，不会返回值 再将isReverse = !isReverse;注意：再导入import java.util.Collections; 33 二叉搜索树的后序遍历序列问：二叉搜索树特点：每个节点的值大于其任意（（左侧子节点的值，小于其任意**右节点的值。输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。答：另外建立一个功能函数。递归判断。private boolean verify(int [] sequence, int first, int last)如果last&lt;=first //已经递归到最后了，返回true;//下面是重点1、定义根节点的值 //也就是序列的最后一个元素2、找出左右树的分界线 //从头到尾开始遍历，左边&lt;根&lt;右。因为是后序，所以找出左 右分界线就是看什么时候不满足元素的值&lt;root的值3、找出树的左右树之后，遍历所有右边的叶子是不是大于根节点的值，不满足就返回false4、到了这一步，说明当前序列的根节点满足二叉树的特点，接下来要判断左右子树是不是也满足。 34 二叉树中和为某一值的路径问：输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)答:1、定义两个全局变量allList（最终结果集） 和 list（路径临时变量），ArrayList&lt;ArrayList&gt; allList=new ArrayList&lt;&gt;();ArrayList list=new ArrayList&lt;&gt;();2、下面才开始写方法里的东西3、root非null判断，返回allList;3、list.add(根节点的值)4、如果根节点的值等于target并且已经没有孩子节点。最终添加入结果集中，必须添加的是list的副本。5、需要注意的是不论路径的值是否等于输入整数值，都要回退，即使用remove函数移除路径上list的最后一个节点。 35 （空，复杂链表不会）36 二叉搜索树与双向链表问：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。答：另写一个功能方法。inorder来完成排序，中序遍历。1、非null判断。2、 inorder(node.left);//这四行完成了双向指向 node.left = pre; if(pre!= null){ pre.right = node; } pre = node; inorder(node.right);3、写主函数，inorder()后再写个while方法找头节点 序列化二叉树（空，不会反序列）38 字符串的排列（空，待做）注：布尔型默认是false 39 数组中出现次数超过一半的数字问：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。如果不存在则输出0。答：多数投票问题。count来计数。1、定义result的值为数组中的第一个元素，count = 1;2、当遍历到的元素和统计元素相等时，令 count++，否则令 count–。如果遍历时，count == 0了，令result 等于遍历到的这个值并且count =1 重新开始数数。继续查找就能找出 result。3、遍历完了之后，无论这个值是不是次数符合要求，都会返回一个result，所以要判断result是否合理。只需要再遍历一次，等于的话count2++ 就行。 40 最小的 K 个数41.1 数据流中的中位数问：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。答：用两个堆，大顶堆和小顶堆，大顶堆放较小的数，小顶堆放较大的数，这样子两个堆的根就是中位数。注意：如何建立大顶堆 小顶堆。private PriorityQueue right = new PriorityQueue&lt;&gt;(); //小顶堆private PriorityQueue left = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1); //大顶堆 字符流中第一个不重复的字符问:请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g”。当从该字符流中读出前六个字符“google” 时，第一个只出现一次的字符是 “l”答:一共有256个字符（0~255），建立一个数组用来计数。建立一个LinkedList 每次插入进去后，计数器加一，都要while检查队列头的字符在count中是不是大于1，是的话就吐出来，说明不符合 42 连续子数组的最大和问：{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。答：令最大值max 和 前面数组和preSum为 为数组中第一个元素接下来从第二个元素开始遍历nums[i]，如果preSum是正数，那就加上这个nums[i]，否认就从当前这个点作为起始点即令preSum = nums[i]。每一次这个遍历之后，都要看看max的值和preSum作比较 45 把数组排成最小的数问:输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。答:可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。 46 解码方法问:给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”… 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。答： 47 礼物的最大价值问: 在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。 答: 动态规划建立一个同大小的 dp 矩阵的话，需要判断边界 i =0 j=0 情况，分四种情况讨论也可以建立一个dp[r+1][c+1] 大小的矩阵，这样的话就只要一种情况。dp[i+1][j+1] = board[i][j] + Math.max(dp[i+1][j], dp[i][j+1]); 49 丑数50 第一个只出现一次的字符位置问：在一个字符串中找到第一个只出现一次的字符，并返回它的位置。答：字符256个，用一个大小为256的数组用来计数。计数完之后再遍历一遍str,看他在数组中的位置是否为1。 51 数组中的逆序对52 两个链表的第一个公共结点答：两个链表接起来 54 二叉查找树的第 K 个结点答：二叉查找树，又名二叉搜索树。中序遍历得结果就是有序的。 56 数组中只出现一次的数字问：一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。答：位运算 全部异或，得到两个融合在一起的xy = bitmask xy柔和在一个bitmask，其中的1必定是两者不一样的位，bitmask &amp; (-bitmask) = bitmask &amp; (~bitamsk + 1) = diff ，得到bitmask是保留位中最右边 1 ，且将其余的 1 设位 0 的方法。由此来区分x y 。注意这一步是并。 再次遍历，如果与diff 并不为0，就异或进来，最后得到一个x 因为 x ^ y = bitmask所以 y = bitmask ^ x 57.2 和为 S 的连续正数序列问: 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序答：双指针。 58.1 翻转单词顺序列问：Input:”I am a student.”; Output:”student. a am I”答: 不使用额外空间 先旋转每个单词，再旋转整个字符串。 58.2 左旋转字符串问: Input: S=”abcXYZdef” K=3; Output:”XYZdefabc”答:先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。 59 滑动窗口的最大值问：输入数组 以及 滑动窗口的大小。 输出最大的答：暴力 60 n个骰子的点数动态规划 6162 圆圈中最后剩下的数用数组模拟环 63 股票的最大利润1234567891011121314151617class Solution &#123; /* 找出数组的最大的差值 */ public int maxProfit(int[] prices) &#123; int max=0; for(int min=0, j=1; j&lt;prices.length;j++)&#123; if(prices[j]&gt;prices[min])&#123; max = Math.max(max, prices[j] - prices[min]); &#125;else&#123; min = j; &#125; &#125; return max; &#125;&#125; 64 使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。 条件与 &amp;&amp; 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 &amp;&amp; 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。 本题的递归返回条件为 n &lt;= 0，取非后就是 n &gt; 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) &gt; 0。 65 不用加减乘除做加法答首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 68.1二叉查找树树中两个节点的最低公共祖先从根节点开始遍历树如果节点 pp 和节点 qq 都在右子树上，那么以右孩子为根节点继续 1 的操作如果节点 pp 和节点 qq 都在左子树上，那么以左孩子为根节点继续 1 的操作如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 pp 和节点 qq 的 LCA 了 1234567891011121314public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root ==null)&#123; return root; &#125; if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right, p, q); &#125; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left, p, q); &#125; return root; &#125; 68.2 普通二叉树中两个节点的最低公共祖先在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。12345678public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null || root ==p || root ==q)&#123; return root; &#125; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); return left==null? right : right==null? left: root; &#125;","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"笔试/面试中遇到的题","slug":"Problem1","date":"2020-02-18T03:04:04.000Z","updated":"2020-06-03T00:52:44.541Z","comments":true,"path":"Problem1/","link":"","permalink":"http://yoursite.com/Problem1/","excerpt":"","text":"字节跳动 5.211 反转字符串ProblemString str = “A retupmoc si a enihcam taht nac eb detcurtsni ot yrrac tuo secneuqes fo citemhtira ro lacigol snoitarepo yllacitamotua aiv retupmoc gnimmargorp”输出正确的顺序：A computer is a machine that can be instructed to carry out sequences of arithmetic or logical operations automatically via computer programming Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;import java.util.Scanner;import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; String str = \"A retupmoc si a enihcam taht nac eb detcurtsni ot yrrac tuo secneuqes fo citemhtira ro lacigol snoitarepo yllacitamotua aiv retupmoc gnimmargorp\"; String [] arr = str.split(\" \"); StringBuilder sb = new StringBuilder(); int len = arr.length; for(int i=0; i&lt;len-1; i++)&#123; String temp = reverse(arr[i]); sb.append(temp); sb.append(\" \"); &#125; sb.append(reverse(arr[len-1])); System.out.println(sb.toString()); &#125; public static String reverse(String s)&#123; char [] arr = s.toCharArray(); int len = arr.length; int l=0; int r = len-1; while(l&lt;r)&#123; char temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; l++; r--; &#125; String re = new String(arr,0, len); return re; &#125;&#125; 2 峰值下标Problem写一个函数，参数是前升后降的数组，返回值是数组峰值对应的下标，例子[1, 2, 4, 5, 7, 9, 8, 6, 3] Solution1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; //Scanner in = new Scanner(System.in); //int a = in.nextInt(); //System.out.println(a); System.out.println(\"Hello World!\"); int[] arr = &#123;1,2,4,5,7,9,8,6,3&#125;; int re = solution(arr); System.out.println(re); &#125; public static int solution(int[] arr)&#123; int l = 0; int r = arr.length-1; int m=0; while(l&lt;=r)&#123; m= l +(r-l)/2; if(arr[m-1]&lt;arr[m] &amp;&amp; arr[m]&gt;arr[m+1])&#123; break; &#125;else if(arr[m-1]&lt;arr[m]&amp;&amp; arr[m]&lt;arr[m+1])&#123; l=m; &#125;else&#123; r=m; &#125; &#125; return m; &#125;&#125; 3 大于前面最大值，小于后面最小值Problem4 3 1 2 7 9 8 10前面所有的数都比其小，后面所有的数都比其大 Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; //Scanner in = new Scanner(System.in); //int a = in.nextInt(); //System.out.println(a); System.out.println(\"Hello World!\"); int [] arr = &#123;4,3,1,2,7,9,8,10&#125;; int count = solution(arr); System.out.println(count); &#125; public static int solution(int [] arr)&#123; int len =arr.length; int[] min = new int[len]; int[] max = new int[len]; max[0] = arr[0]; for(int i=1; i&lt;len; i++)&#123; max[i] = Math.max(max[i-1], arr[i]); &#125; min[len-1] = arr[len-1]; for(int i=len-2; i&gt;=0; i--)&#123; min[i] = Math.min(min[i+1], arr[i]); &#125; int count = 0; if(arr[0]&lt;min[1])&#123; //System.out.println(arr[0]); count++; &#125; if(arr[len-1]&gt;max[len-2])&#123; count++; //System.out.println(arr[len-1]); &#125; for(int j =1; j&lt; len-1; j++)&#123; if(arr[j]&gt;max[j-1] &amp;&amp; arr[j]&lt;min[j+1])&#123; count++; // System.out.println(arr[j]); &#125; &#125; return count; &#125;&#125; 拼多多5.61 2 火柴拼正方形 3 4 打乱数组Problem使用最熟悉的编程语言，实现函数：数组array，存放着不同的数字，要求：a) 尽量打乱数组arrayb) 数字不能在原位置重复 按照指定步长反转链表Problem实现一个函数，给定步长m，每m个节点一组反转单链表，写出函数。 逛街Problem小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） 例如：m=2，a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f 变成 b-&gt;a-&gt;d-&gt;c-&gt;f-&gt;e 差值数组的最大公约数Problem题目描述：牛牛有一个长度为n的数组a，你要找一个最大的正整数d，使得对于所有i（1≤i≤n），ai+1-ai是d的倍数，即ai+1-ai=kd(k&gt;1)输入：第一行一个正整数n（取值[2,2100000]）第二行n个正整数a1-an（1≤ai≤10^18）输出：若d不存在，输出-1，否则输出最大的d Solution 用一个Scanner 来接受第一个数，new 数组，大小为n 计算差值判断每个差值：&lt;0: 输出 -1.return 计算完差值后，判断size大小size == 0 : 原数组只有一个数，没有差值，-1 returnsize == 1 : 原数组只有两个数，差值只有一个，那这个值就是最大公约数 return 普遍情况是由大于等于两个差值那就用辗转相除法找其最大公约数（先找两个的，这个结果再与第三个，。。。以此类推）；注意：10^18超过int(-2^31-1~2^31)范围，用 long 两/多个数字的最大公约数求法：辗转相除法 Code1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.IOException;import java.util.ArrayList;import java.util.Scanner;public class Chazhishuzu &#123; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long [] input = new long[n]; ArrayList&lt;Long&gt; list = new ArrayList&lt;&gt;(); for(int i =0; i&lt; n; i ++)&#123; input[i] = sc.nextLong(); if(i&gt;=1)&#123; long temp = input[i] - input[0]; if(temp&lt;=0)&#123; System.out.println(-1); return; &#125; list.add(temp); &#125; &#125; if(list.size()==0)&#123; System.out.println(-1); return; &#125; if(list.size()==1)&#123; System.out.println(list.get(0)); &#125; long res = list.get(0); for(int i=1; i&lt;list.size(); i++)&#123; res = gcd(res, list.get(i)); &#125; System.out.println(res); &#125; public static long gcd(long a, long b)&#123;//辗转相除法 if(b==0)&#123; return a; &#125; return gcd(b,a%b); &#125;&#125; 找aj减ai的最大值Problem有一个数组a，找aj减ai的最大值，且满足j大于i？返回该最大值，以及对应的i，j下标。要求是时间复杂度O(n),空间复杂度O(1)。 Solution题目的要求是时间复杂度O(n),空间复杂度O(1)。 两个错误的思路要避免，一是数组排序，最好的排序算法时间复杂度也是nlogn,明显达不到要求。另外一个是遍历数组求得最大值和最小值，然后相减，但照顾不到i&lt;=j的条件。 正确的思路是对上述第二个算法的改进，将数组第一个元素设置为最大和最小值（i=j=0），最大差值的初始值max就是0，然后移动j，每次移动都计算a[j]-a[i]，如果结果大于max就替换max，小于的话什么都不做，而如果结果小于0，则将i赋值为j，继续上面的操作。最终得到的结果就是正确答案。 Code12345678910111213141516171819202122232425262728293031323334public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); int a[] = &#123;6,18,3,98,67,24,0,43,17,17,67,81,49,-15,9&#125;; int[] maxArr = max(a); System.out.println(maxArr[0]); System.out.println(maxArr[1]); System.out.println(maxArr[2]); &#125; public static int[] max(int[] arr)&#123; int result = arr[0] - arr[0]; int[] resultArr = new int[3]; int i = 0; int j = 0; int resultI = 0; int resultJ = 0; for(j=1; j&lt; arr.length;j++)&#123; if(arr[j]- arr[i]&gt;result)&#123; result = arr[j]- arr[i]; resultI = i; resultJ = j; &#125;else if(arr[j]- arr[i] &lt; 0)&#123; i = j; &#125; &#125; resultArr[0] = result; resultArr[1] = resultI; resultArr[2] = resultJ; return resultArr; &#125;&#125;","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"十大经典排序算法","slug":"paixu","date":"2020-02-17T11:42:01.000Z","updated":"2020-02-24T14:33:42.061Z","comments":true,"path":"paixu/","link":"","permalink":"http://yoursite.com/paixu/","excerpt":"","text":"总图稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中1领先于2,那么排序后1如果仍旧领先2的话，则是稳定的。（相等的元素排序后相对位置不变） 冒泡排序1、把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置….2、我们对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来之后，排在最右的元素就会是最大的数。3、除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。12345678910111213public static int[] BubbleSort(int [] a)&#123; int len = a.length; for(int i = 0; i&lt; len; i++)&#123; for(int j =1; j&lt; len-i;j++)&#123; if(a[j]&lt;a[j-1])&#123; int temp = a[j]; a[j] = a[j-1]; a[j-1] = temp; &#125; &#125; &#125; return a; &#125; 选择排序1、首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。2、其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。3、如此往复，直到将整个数组排序。1234567891011121314151617public static int[] selectSort(int[] a) &#123; int len = a.length; for(int i =0; i&lt; len-1; i++)&#123; //找出剩余的最小的那个坐标 int min = i; for(int j =i+1; j&lt;len;j++)&#123; if(a[j]&lt;a[min])&#123; min = j; &#125; &#125; //交换 int temp = a[i]; a[i] = a[min]; a[min] = temp; &#125; return a; &#125; 插入排序1、从数组第2个元素开始抽取元素。2、把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边。3、继续选取第3，4，….n个元素,重复步骤 2 ，选择适当的位置插入。12345678910111213141516public static int[] insertSort(int[] a)&#123; int len = a.length; for(int i=1; i&lt; len; i++)&#123; //从后往前找出最合适的位置，要交换位置，要倒着开始交换 for(int j = i; j&gt;0; j--)&#123; if(a[j]&lt;a[j-1])&#123; int temp = a[j]; a[j] = a[j-1]; a[j-1] = temp; &#125;else&#123; //不用一直遍历到0，一旦不符合了，就说明换完了，就跳出内循环 break; &#125; &#125; &#125; return a; &#125; 希尔排序（插入排序的变种）希尔排序的思想是采用插入排序的方法1、先让数组中任意间隔为 h 的元素有序2、刚开始 h 的大小可以是 h = n / 2，接着让 h = n / 4，3、让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。 归并排序（重点，待补充代码）1、将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。2、通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。 快速排序（重点）对挖坑填数进行总结1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。123456789101112131415161718192021222324252627public static int[] quickSort(int s[], int l, int r) &#123; if (l &lt; r) &#123; int i = l, j = r, x = s[l]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j] &gt;= x)&#123;// 从右向左找第一个小于x的数 j--; &#125; if(i &lt; j)&#123; s[i++] = s[j]; &#125; while(i &lt; j &amp;&amp; s[i] &lt; x)&#123; // 从左向右找第一个大于等于x的数 i++; &#125; if(i &lt; j)&#123; s[j--] = s[i]; &#125; &#125; s[i] = x; quickSort(s, l, i - 1); // 递归调用 quickSort(s, i + 1, r); &#125; return s; &#125; 堆排序1、根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。2、每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。 计数排序计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。 桶排序1、桶排序就是把最大值和最小值之间的数进行瓜分，例如分成 10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去2、再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。之后每个桶里面的数据就是有序的了，我们在进行合并汇总。 基数排序1、先以个位数的大小来对数据进行排序，接着以十位数的大小来对数进行排序，接着以百位数的大小……2、排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。由于某位数（个位/十位….，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了 参考文献必学十大经典排序算法，看这篇就够了菜鸟网站排序算法总结Jack Cui 堆排序","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"Java 中的小知识点","slug":"java-tips","date":"2020-02-16T08:00:32.000Z","updated":"2020-04-21T13:45:29.267Z","comments":true,"path":"java-tips/","link":"","permalink":"http://yoursite.com/java-tips/","excerpt":"","text":"如何输入数组未知数组大小123456789System.out.println(\"请输入几个数并用逗号隔开：\");Scanner sc = new Scanner(System.in);String str = sc.next().toString();String[] arr = str.split(\",\");int[] b = new int[arr.length];for(int j = 0; j&lt;b.length;j++) &#123; b[j] = Integer.parseInt(arr[j]); System.out.println(b[j]+\" \");&#125; 已知数组大小12345678System.out.println(\"请输入三个数：\");Scanner in = new Scanner(System.in);int[] b2=new int[3];for(int j=0;j&lt;b2.length;j++)&#123; b2[j]=in.nextInt();&#125;System.out.println(Arrays.toString(b2));&#125; Java中的8种基本类型是什么? 面向对象的三个基本特征 和 五种设计原则三个基本特征：封装、继承、多态。五大原则:单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、良性依赖原则 int 和 Integer 区别是否相等Integer直接赋值（不是new）是在常量池中的同一空间，但是有范围（-128-127），如果超出了范围，会从堆区new一个Integer对象来存放值。12345678910111213141516171819Integer a=17;Integer b=17;Integer c=1000;Integer d=1000;System.out.println(a==b); // trueSystem.out.println(c==d); // falseint a=17;int b=17;int c=1000;int d=1000;System.out.println(a==b); // trueSystem.out.println(c==d); // trueInteger a = new Integer(3);Integer b = 3; // 将3自动装箱成Integer类型int c = 3;System.out.println(a == b); // false 两个引用没有引用同一对象System.out.println(a == c); // true a自动拆箱成int类型再和c比较 权限修饰符 类内部 本包 子类 外部包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 抛出异常在方法后面加上 throws Exception使用的时候 throw new Exception(“xxx”);1234567public int pop() throws Exception&#123; if(stack.empty())&#123; throw new Exception(\"queue is empty\"); &#125; return stack.pop(); &#125;","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"【Java解决报错】发生异常WRONGTYPE Operation against a key holding the wrong kind of value","slug":"error-reids","date":"2020-02-10T14:34:48.000Z","updated":"2020-02-10T15:52:06.132Z","comments":true,"path":"error-reids/","link":"","permalink":"http://yoursite.com/error-reids/","excerpt":"","text":"报错内容发生异常WRONGTYPE Operation against a key holding the wrong kind of value 解决方法 原因：redis 存储的数据类型与所用方法要求的类型不一致 首先CMD，连接redis服务，进入到指定数据库，查看所存储的数据类型。可以看到FOLLOWEE 和 FOLLOWER 类型为zset，LKE类型为set。 查看到数据类型之后，在调用Jedis的地方检查下，所用的命令是不是与类型匹配。可以看到这里的scard是错误使用在zset类型上，应改为zcard。正确如下： 1234public long getFolloweeCount(int userId, int entityType)&#123; String followeeKey = RedisKeyUtil.getFolloweeKey(userId,entityType); return jedisAdapter.zcard(followeeKey); &#125;","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"遍历map的四种方法","slug":"map","date":"2020-02-06T07:50:18.000Z","updated":"2020-02-06T08:28:27.999Z","comments":true,"path":"map/","link":"","permalink":"http://yoursite.com/map/","excerpt":"","text":"Map.entrySet() 这个方法返回的是一个Set&lt;Map.Entry&lt;K,V&gt;&gt;，Map.Entry 是Map中的一个接口，他的用途是表示一个映射项（里面有Key和Value），而Set&lt;Map.Entry&lt;K,V&gt;&gt;表示一个映射项的Set。Map.Entry里有相应的getKey和getValue方法，即JavaBean，让我们能够从一个项中取出Key和Value。 下面是遍历Map的四种方法:12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"1\", \"value1\"); map.put(\"2\", \"value2\"); map.put(\"3\", \"value3\"); //第一种：普遍使用，二次取值 System.out.println(\"通过Map.keySet遍历key和value：\"); for (String key : map.keySet()) &#123; System.out.println(\"key= \"+ key + \" and value= \" + map.get(key)); &#125; //第二种 System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println(\"通过Map.entrySet遍历key和value\"); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); &#125; //第四种 System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key\"); for (String v : map.values()) &#123; System.out.println(\"value= \" + v); &#125; &#125; 参考文献：https://blog.csdn.net/gm371200587/article/details/82108372","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"Problem2 随机数生成器","slug":"Problem2","date":"2020-02-06T03:22:32.000Z","updated":"2020-02-18T07:05:28.921Z","comments":true,"path":"Problem2/","link":"","permalink":"http://yoursite.com/Problem2/","excerpt":"","text":"随机数生成器 (1)有一枚不均匀的硬币，可以概率p投出正面，1-p反面，且p不等于0.5。问如何投掷该硬币来设计一个随机数生成器，使得以等概率输出0，1？Solution:设：正为0为p，反为1为1-p。 Number Probability 00 pp 01 p(1-p) 10 p(1-p) 11 (1-p)(1-p) 注意到01和10 的概率是相等的，概率为 p(1-p)。那就可以将01对应输出0，10对应输出1，其余的都舍掉。这样就可以等概率P输出0，1。(2) 推广到等概率输出n个数的情况？Solution: 这种解法可以推广到n个数的情况，生成的00…001对应0，00…010对应1，00…100对应2，……，01…000对应n-1，10…000对应n，概率均为$p^n(1-p)$，可以等概率输出。其余的都舍掉。 (3) 等概率0 1随机数生成器为的0的期望？Solution: 每次试验都是独立的。输出结果只有0，1 两种，所以这是伯努利试验，将伯努利试验独立重复n次，称为n重伯努利试验。若每次试验成功的概率为p(0&lt;p&lt;1)，则在第k次试验才首次成功的概率服从几何分布。第k次才成功的概率P(ξ=k)=(1-p)的(k-1)次方乘以p (k=1，2，…，0&lt;p&lt;1)。期望是1/p，方差是 (1-p)/(p的平方)。","categories":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}],"keywords":[{"name":"有趣的题","slug":"有趣的题","permalink":"http://yoursite.com/categories/有趣的题/"}]},{"title":"使用Pyspider爬虫网站数据","slug":"pyspider","date":"2020-01-09T05:34:41.000Z","updated":"2020-02-10T15:47:14.183Z","comments":true,"path":"pyspider/","link":"","permalink":"http://yoursite.com/pyspider/","excerpt":"","text":"环境搭建pyspider 介绍pyspider 是一个基于Python语言的功能强大的爬虫框架，支持在浏览器界面进行代码调试，对爬取状态、进度和结果实时查看，支持多线程工作。更多请查看官方文档。 系统环境 Windows 10 Python 3.6 安装首先搭建环境，注意pyspider与python3.7 因为关键字冲突而不兼容，需要进行繁琐的配置。因此，我使用了Python 3.6。安装pyspider:1pip install pyspider 但是 报错缺少依赖包 pycurl。到网站https://www.lfd.uci.edu/~gohlke/pythonlibs/找到pycurl，下载自己对应的版本如何下载自己所对应的的第三方依赖包的版本？在cmd中输入pyhton：12Python 3.6.8 |Anaconda, Inc.| (default, Feb 21 2019, 18:30:04) [MSC v.1916 64 bit (AMD64)] on win32Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. 由此可知，我的Python 为3.6.8 64bit (AMD64)。所以下载的pycurl 为：1[pycurl‑7.43.0.3‑cp36‑cp36m‑win_amd64.whl](javascript:; \"[3.1 MB] [Jun 23, 2019]\") 其中： cp36: Pyhton 3.6 amd64: 64位 另外，如果爬取的页面中，有带JS的页面，则需要安装 PlantomJS ，安装教程如下：点击https://phantomjs.org/download.html，下载Windows版本，然后解压缩出来后，将\\bin 目录下的 phantomjs.exe 文件放到 Python.exe 的同级目录下即可。 配置好环境后，运行Pyspider：1pypider all 可以看到phantomjs 已经运行， pyspider运行在 http://127.0.0.1:5000/ 端口，下为pyspider dashboard界面。至此，环境已经配置成功。注意CMD窗口不要关闭，否则端口将失效。 爬虫实例需求：以 https://www.luoow.com/ 为例，爬取该网站的999个歌单的数据信息（歌单名称，歌曲数目，歌单介绍，歌单封面链接，歌单中每个歌曲的名称及歌手名称），并以json格式保存在txt文本文件中。 新建任务 Project Name: 项目的名称，自己可以随意填写。 Start URL(s): 项目爬取的目标网址。 下为系统自动生成的初始化界面： 代码编写与调试代码的编写需要用到CSS选择器的知识，在目标网页右键检查有几种常用的格式： 获取这行所指的文本 比如 vol.5 A New Begining 123response.doc('div[class=\"title\"]').text() #input[id = “code”] id属性为code的input标签。.text()表示返回文本。或者response.doc('div.title').text() #是上文的简写形式，表示class为title的div标签 获取这个图片的网址： 1picture = response.doc('img.img-responsive').attr.src #attr.src 表示属性中src的值。 以下为我最终写的爬取落网歌单的Python代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/env python#-*- encoding: utf-8 -*-#Created on 2020-01-09 10:17:30#Project: 999from pyspider.libs.base_handler import * import jsonclass Handler(BaseHandler): def __init__(self): self.base_url = 'http://www.luoow.com/' self.start = 1 self.end = 999 crawl_config = &#123; &#125; @every(minutes=24 * 60) def on_start(self): self.crawl('http://www.luoow.com/', callback=self.index_page) @config(age=10 * 24 * 60 * 60) def index_page(self, response): while self.start &lt;= self.end: url = self.base_url + str(self.start) print(url) self.crawl(url, callback=self.detail_page, fetch_type= 'js') #fetch_type= 'js' 表示打开有JS渲染的界面，本示例中的歌单均有JS，否则抓取不成功。 self.start += 1 @config(priority=2) def detail_page(self, response): songer_name= [] song_name = [] picture = response.doc('img.img-responsive').attr.src for each in response.doc('span[class = \"skPlayer-list-author\"]').items(): #class 里面不能有空格 songer_name.append(each.text()) for each in response.doc('span[class = \"skPlayer-list-name\"]').items(): song_name.append(each.text()[4:]) song_count = len(song_name) all_song = [] for i in range(song_count): current_song = &#123; \"song_name\" : song_name[i], \"songer_name\" : songer_name[i] &#125; all_song.append(current_song) all = &#123; \"name\": response.doc('div.title').text(), \"song_count\": song_count, \"introduction\" : response.doc('div[class = \"vol-desc\"]').text(), \"img_url\" : picture, \"songs\" : all_song &#125; with open(r\"E:\\project\\python\\spider\\999.txt\", \"a\",encoding='utf-8') as f: # 1. 一定要说明 utf-8 编码，否则会报错，无法正常显示非英文字符。 2. 读取方式为 \"a\" 表示为 不覆盖文件中。 f.write(json.dumps(all,ensure_ascii = False)) #ensure_ascii = False 在txt 中，使得中文可以正常显示 f.write(',') #在每个歌单之间加上 ‘，’号，以符合json格式。 return &#123; #return 的数据会返回到dashboard的results中 \"name\": response.doc('div.title').text(), \"song_count\": song_count, \"introduction\" : response.doc('div[class = \"vol-desc\"]').text(), \"img_url\" : picture, \"songs\" : all_song &#125; pyspider 支持在线调试并实时查看爬虫结果。 调试无误后，返回 pyspider dashboard 界面。 运行调试完成后，将该项目的CHECKING 改为 RUNNING，并点击Run，pyspider 就开始爬虫工作了。运行后Results中开始刷新数据，并且CMD窗口中也一直在显示爬取结果。 各参数的含义为： rate/burst 代表当前的爬取速率。rate 代表 1 秒发出多少个请求，burst 相当于流量控制中的令牌桶算法的令牌数，rate 和 burst 设置的越大，爬取速率越快，当然速率需要考虑本机性能和爬取过快被封的问题。 process 中的 5m、1h、1d 指 的是最近 5 分、1 小时、1 天内的请求情况，all 代表所有的请求情况。 颜色请求由不同颜色表示、蓝色的代表等待被执行的请求，绿色的代表成功的请求，黄色的代表请求失败后等待重试的请求，红色的代表失败次数过多而被忽略的请求，这样可以直观知道爬取的进度和请求情况。 Run 爬虫运行的按钮。 Active Tasks 可以看到任务进行的状态，比如爬到哪个网址了，以及是否爬取成功等。 Results 爬虫结果。 爬虫结果 点击Results后查看，已经成功得到了所需要的信息。可以点击右上角进行保存。 txt文件。由于我的需求是将爬取结果以json格式保存为txt，故我在源码中使用write方法将爬虫结果保存下来： 123with open(r\"E:\\project\\python\\spider\\999.txt\", \"a\",encoding='utf-8') as f: # 1. 一定要说明 utf-8 编码，否则会报错，无法正常显示非英文字符。 2. 读取方式为 \"a\" 表示为 不覆盖文件中。 f.write(json.dumps(all,ensure_ascii = False)) #ensure_ascii = False 在txt 中，使得中文可以正常显示 f.write(',') #在每个歌单之间加上 ‘，’号，以符合json格式。 注：为了符合json格式要求，[{…},{…},{…}]需要手动修改，删除掉txt文件末尾的最后一个“，”，并在首尾处分别加上“[” “]”。 格式校验打开在线JSON校验格式化工具（Be JSON）复制txt文件中的内容到该网站，点击格式化校验，可以看到所得到的json为正确格式。 至此，已经成功爬取到了落网所有歌单的数据，并以正确的json格式保存在txt文件中。由于，此次不涉及数据库和反爬机制，暂不做赘述。 附录代码源码：点击下载源码 csv: 点击下载CSV文件 注：关于CSV乱码问题的解决方案： 单击该CSV文件，右键以记事本方式打开，另存为的时候将编码方式改为ANSI，再次打开显示正常。 参考文献[1] pyspider的使用[2] CSS 选择器参考手册[3] pyspider 爬虫教程（三）：使用 PhantomJS 渲染带 JS 的页面","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"【吉他指弹】November","slug":"November","date":"2019-12-08T13:26:59.000Z","updated":"2020-10-13T14:36:52.527Z","comments":true,"path":"November/","link":"","permalink":"http://yoursite.com/November/","excerpt":"简介 是什么支撑我们零下的温度去拍外景 ——当然是故宫的初雪? 哈哈，2019的最后一个视频来咯。《November》cover 岸部真明。 感谢寒风瑟瑟中陪我拍视频的两个老友@沨，@北北 PS: 观影三感受 我的脸已经和地球一样圆了 我的头发日渐稀疏 没有露脸的镜头看着都好好看 哈哈哈哈哈哈嗝","text":"简介 是什么支撑我们零下的温度去拍外景 ——当然是故宫的初雪? 哈哈，2019的最后一个视频来咯。《November》cover 岸部真明。 感谢寒风瑟瑟中陪我拍视频的两个老友@沨，@北北 PS: 观影三感受 我的脸已经和地球一样圆了 我的头发日渐稀疏 没有露脸的镜头看着都好好看 哈哈哈哈哈哈嗝 视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/November/November.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/November/November.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"基于脑机接口技术实现意念播放音乐","slug":"BCI","date":"2019-11-15T13:28:54.000Z","updated":"2020-02-07T14:15:07.945Z","comments":true,"path":"BCI/","link":"","permalink":"http://yoursite.com/BCI/","excerpt":"有没有那样一天，可以用大脑的意念来做一些事情，比如播放音乐，打开门等。用看不见的脑电波来控制设备，是不是很神奇。","text":"有没有那样一天，可以用大脑的意念来做一些事情，比如播放音乐，打开门等。用看不见的脑电波来控制设备，是不是很神奇。 功能用意念打开音响并播放一段音乐 工具 脑立方蓝牙传感器 电脑 蓝牙音箱 Matlab软件 方法 方案流程图 通过BCI脑-机接口技术以及BP神经网络算法，实现对脑电信号的数据采集、特征熵值提取、分析处理以及对外部设备的控制，整体方案设计流程为： (1) 脑电信号数据：基于脑电信号模式识别的远程遥控应用是对想象左右手运动（对应蓝牙音箱连接或断开）的二分类问题。首先采集受试者的脑电信号数据，共采集两组脑电信号数据：A组为想象左手运动（蓝牙音箱连接），B组为想象右手运动（蓝牙音箱断开）。 (2) 信号特征熵值提取：将脑电信号alpha波、beta波和gamma波进行数据归一化处理。其中alpha波与放松和冥想状态有关，beta波与思想专注状态有关，gamma波与某些感应的记忆相关的状态有关。将提取到的脑电波数据（三种波形各两组，共六组）分别进行熵值运算得到特征值矩阵。把熵值作为神经网络的输入，确定神经网络的预期输出，基于其特征熵值矩阵进行神经网络训练，确定神经网络的模型参数。 (3) 神经网络训练：创建BP神经网络，用带标签的样本数据训练BP神经网络模型的参数权值。 输入层神经元个数：特征提取采用基于脑电信号求熵值的方法，得到6组熵值，因此网络的输入层神经元个数为 6 个。 输出层神经元个数：BP神经网络输出层的神经元个数依据所需要识别的特征确定，输出层神经元个数确定为1。 隐含层层数：３。 隐含层神经元个数：采用经验公式与实验相结合的方式来确定。对于由m 个输入神经元、 n 个输出神经元的神经网络，其隐含层神经元的个数可以根据如下经验公式进行确定，隐含层神经个数确定为13。$$h=\\sqrt{(n+m)+a}, a∈[1,10]$$ (4) 网络测试验证：将特征熵值数据的测试集，载入已经训练好的BP神经网络对其进行测试，最后将预测输出结果与实际期待结果进行仿真对比，进而检查网络对其分类的正确性。由于A组与B组想象的是相反的运动，所以测试集经过神经网络后应得到相反的结果。若测试集的准确率较低，则增加采集脑电波信号，增加训练集数据量，采集大量的脑电信号重新训练网络。 (5) 人机交互：想象抬左手对应播放音乐，右手反之。1234b = Bluetooth('HUAWEI AM08',3); #创建蓝牙串口对象[y,Fs] = audioread('D:\\Music\\我和我的祖国.mp3'); #创建音乐对象 fopen(b); #打开蓝牙sound(y,Fs); #播放音乐 (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/BCI/3s.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/BCI/fengmian.png\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 总结成功用意念控制外设，完成预期目标。缺陷是只能实现简单二分类，网络功能简单。","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"【吉他指弹】蝶恋花","slug":"dieLianHua","date":"2019-10-07T14:53:24.000Z","updated":"2020-10-13T14:37:08.093Z","comments":true,"path":"dieLianHua/","link":"","permalink":"http://yoursite.com/dieLianHua/","excerpt":"简介 翻弹一首曹思义的中国风指弹曲。","text":"简介 翻弹一首曹思义的中国风指弹曲。 视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer3\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/dieLianHua/dieLianHua.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/dieLianHua/dieLianHua.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"【Java解决报错】IDEA中Spring Boot启动报错Application startup failed","slug":"IDEA","date":"2019-10-06T14:39:54.000Z","updated":"2020-02-10T15:52:20.547Z","comments":true,"path":"IDEA/","link":"","permalink":"http://yoursite.com/IDEA/","excerpt":"","text":"报错内容解决IDEA中Spring Boot启动报错Application startup failed1ERROR 17040 [main] o.s.boot.SpringApplication : Application startup failed 解决方法原因：工程要求的JDK版本与环境所配置的JDK版本不同所致。 pom.xml文件中所要求的为 1.8 1234&#123;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&#125; 导入工程后，查看默认的JDK，更改为1.8 路径为 File -&gt; Project Structure -&gt;Platform Settings -&gt;SDKs 点击”+”号，添加版本为1.8的JDK所在的根目录 修改Project SDK 和Module SDK 为1.8","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"798","slug":"798","date":"2019-09-29T02:24:19.000Z","updated":"2020-02-10T15:48:19.322Z","comments":true,"path":"798/","link":"","permalink":"http://yoursite.com/798/","excerpt":"","text":"久负盛名的 798 艺术中心，是北京的拍照打卡圣地，于是在一个惬意的周末，和老友相聚于此。今天的目标是给闺蜜拍出来美美的照片~cool girl!(❤ ω ❤)) 下面一组照片，是在一个废弃的工厂，色调均调冷了一些，凸显工业风 然后来到涂鸦墙，各种墙~ 绿色代表生命，黄色代表纯洁的美好和希望。 最后PO两张合照，今天是男友力MAX的一天，啊哈哈哈哈","categories":[{"name":"摄影游记","slug":"摄影游记","permalink":"http://yoursite.com/categories/摄影游记/"}],"tags":[],"keywords":[{"name":"摄影游记","slug":"摄影游记","permalink":"http://yoursite.com/categories/摄影游记/"}]},{"title":"【吉他指弹】Time Travel","slug":"timeTravel","date":"2019-09-15T05:22:03.000Z","updated":"2020-10-13T14:29:39.154Z","comments":true,"path":"timeTravel/","link":"","permalink":"http://yoursite.com/timeTravel/","excerpt":"简介 第一次听Time travel，心想吉他还可以这样玩，后来了解了这种演奏风格————Fingerstyle guitar，指弹。几年前自己特别喜欢的曲子，如今有一天可以完整的演奏下来。 时间在旅行，我们在成长。","text":"简介 第一次听Time travel，心想吉他还可以这样玩，后来了解了这种演奏风格————Fingerstyle guitar，指弹。几年前自己特别喜欢的曲子，如今有一天可以完整的演奏下来。 时间在旅行，我们在成长。 视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer8\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/timeTravel/timeTravel.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/timeTravel/timeTravel.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"雍和宫","slug":"雍和宫","date":"2019-08-05T16:22:46.000Z","updated":"2020-02-10T15:49:38.366Z","comments":true,"path":"雍和宫/","link":"","permalink":"http://yoursite.com/雍和宫/","excerpt":"","text":"五道营胡同不长，却有满满文艺气息，各种装修精美的小店铺，街上人不是很多。走出胡同，就来到雍和宫门外大街，此次红墙素材，没错就来自雍和宫门外的墙。和燕燕两人一路溜达，然后捕捉路人为我俩拍合影。又被说长得像，那还不是因为咱俩脸都是又大又方。(●ˇ∀ˇ●) 红墙真的是很适合拍照啊，再写几个古字，感觉就来了。 最后一张，是我近期P过最满意的一张图了，燕燕要拥有三倍的快乐呦！","categories":[{"name":"摄影游记","slug":"摄影游记","permalink":"http://yoursite.com/categories/摄影游记/"}],"tags":[{"name":"北京游记","slug":"北京游记","permalink":"http://yoursite.com/tags/北京游记/"}],"keywords":[{"name":"摄影游记","slug":"摄影游记","permalink":"http://yoursite.com/categories/摄影游记/"}]},{"title":"蘑菇空间","slug":"moGu","date":"2019-07-22T10:18:56.000Z","updated":"2020-02-10T15:50:17.293Z","comments":true,"path":"moGu/","link":"","permalink":"http://yoursite.com/moGu/","excerpt":"","text":"在北京一个好处是，有很多好玩的演出之类，而且有的还是免费。于是在一个周日的晚上，和我室友——两个贫穷的文艺青年，骑单车来到了距离学校不远的『蘑菇空间』，一个小型Live House。这次演出嘉宾有两个，上半场是民谣，下半场是指弹。(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer4\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/moGu/C0011.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/moGu/DSC00454.JPG\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 人不是很多，氛围还不错，有的独自前来，或与朋友结伴，都安安静静地听音乐。 本来演出公告上面写的是民谣弹唱会，出乎意料竟然有指弹节目，炒鸡开心。大哥是押尾桑的粉丝，翻弹了几首他的曲子，最后是《Merry Christmas Mr. Lawrence》，亲爱的劳伦斯先生，圣诞节快乐。(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer5\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/moGu/C0026.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 演出结束，大家很快就走完了，于是我和室友开始拍照模式，哈哈哈。","categories":[{"name":"摄影游记","slug":"摄影游记","permalink":"http://yoursite.com/categories/摄影游记/"}],"tags":[{"name":"live现场","slug":"live现场","permalink":"http://yoursite.com/tags/live现场/"}],"keywords":[{"name":"摄影游记","slug":"摄影游记","permalink":"http://yoursite.com/categories/摄影游记/"}]},{"title":"【吉他指弹】感受清晨的阳光","slug":"感受清晨的阳光","date":"2019-07-01T17:12:51.000Z","updated":"2020-10-13T14:30:33.655Z","comments":true,"path":"感受清晨的阳光/","link":"","permalink":"http://yoursite.com/感受清晨的阳光/","excerpt":"简介 去年夏天，在岸部真明的音乐会上第一次听到这曲子。 觉得整个人都要升华了，只想闭上眼睛静静听。 视频拍摄于傍晚，感受下黄昏大气恢弘的阳光吧！","text":"简介 去年夏天，在岸部真明的音乐会上第一次听到这曲子。 觉得整个人都要升华了，只想闭上眼睛静静听。 视频拍摄于傍晚，感受下黄昏大气恢弘的阳光吧！ 视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer10\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/ganShouQingChenDeYangGuang/ganShouQingChenDeYangGuang.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/ganShouQingChenDeYangGuang/ganShouQingChenDeYangGuang.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"3GPP下的5G与卫星融合","slug":"3GPP下的5G与卫星融合","date":"2019-06-02T14:07:30.000Z","updated":"2019-10-06T15:41:06.727Z","comments":true,"path":"3GPP下的5G与卫星融合/","link":"","permalink":"http://yoursite.com/3GPP下的5G与卫星融合/","excerpt":"","text":"随着通信的发展，单一的地面网络已经不能满足一些场景的需求，融合了卫星通信的天地一体化网络成为研究的热点。 过去二十年，3GPP成为引领全球通信业发展的主导性标准化组织。特别是进入5G时代，3GPP的影响力进一步彰显。3GPP提供TS（Technical specification，技术规范）和TR（Technical request，技术报告）,TS成文并冻结后往往意味着要投入商用阶段，“冻结”的意思是对该Release只允许进行必要的修正，而不再添加新的特性。而TR则是针对某个专题所做的研究。一个重要的课题一般会先经过研究阶段，发布一系列的TR，然后再进行标准化制定工作，发布TS。 3GPP最早在R14中开展了卫星通信对5G地面移动通信带来的优势的研究。为了推动卫星技术在5G中的应用，3GPP在SA以及RAN工作组中先后成立了多个5G卫星融合相关的研究项目，将卫星接入列为5G的多种接入技术之一，并对卫星网络的部署方案和应用场景进行了具体研究和分析。为了加速5G的发展，新一代移动通信技术标准分成了R15、R16两大阶段。R15目前已经冻结，R16预计2020年3月完成。期间3GPP在5G与卫星融合方面作出了不懈努力，并取得了一系列的成果，下图是一些重要提案的时间节点。 下面对上述的提案作出简要介绍： TS 22.261(R15)《Service requirements for next generation new services and markets》中阐述了卫星覆盖作为5G混合接入技术之一所带来的前景和价值，卫星在一些要求广域覆盖的工业应用场景中具有显著优势。并提出了卫星通信相关的需求：5G系统要提供卫星接入功能，并且5G系统应支持由同一运营商或运营商间协议拥有的陆地5G接入和卫星接入网络之间的服务连续性；为了提供使用卫星接入的服务，5G系统的空中接口应支持高达280 ms的单向延迟；拥有卫星接入的5G系统应该能够通过利用卫星支持无处不在的服务，以及对全球覆盖范围进行广播/多播业务，优化内容缓存应用程序的传输等。作为5G接入技术之一，卫星通信市场潜力不容小觑，但面临的挑战也是巨大的。 TR 22.822(R16)《Study on using Satellite Access in 5G》是在TS22.261基础上对5G卫星接入的进一步研究，列举了卫星融合5G的12个应用场景，分别是：1. 需要跟踪定位服务的海上船只；2. 卫星覆盖的广播/多播业务；3. 基于卫星接入的物联网；4. 卫星网络的应急通信；5. 卫星的最优路径；6. 卫星越境服务的连续性；7. 全球卫星覆盖方案；8. 通过弯管卫星将UE连接到5G网络；9. NR与5G核心之间的固定回程；10. 5G移动平台回程；11. 5G前提；12. 远程服务中心与离岸风电场的卫星连接。上述12类应用场景覆盖了卫星通信的三种服务类型，即服务连续性，服务普遍性，服务可扩展性。该技术报告对终端和原有地面网络提出新要求，结合对5G卫星网络应用场景的分析，对已有服务进行修改和更新，这是实现5G网络产业应用的关键环节。 TR 23.737(R16)《Study on architecture aspects for using satellite access in 5G》在考虑TR22.822提出的十二个应用场景时，确定集成了卫星通信在内的5G系统的影响区域。分析了由于卫星覆盖范围大和本身可移动带来的UE移动性管理问题、时延问题、QoS等。 TR 38.811(R15)《Study on New Radio (NR) to support Non Terrestrial Networks》该报告由RAN和WG1工作组撰写，面向非地面网络的5G新空口，针对5G应用场景的需求以及现有卫星技术的发展水平，确定卫星网络部署方案以及相关参数，这是保障5G系统卫星通信功能和性能需求的关键； TR 38.821(R16)《Solutions for NR to support non terrestrial networks (NTN)》在TR 38.811成果的基础上，3GPP研究一套必要的适配措施，使新无线电(NR)协议可在非地面网络中运作，并优先接入卫星服务的3GPP的R16版本。非地面网络也要考虑无人机系统的接入，无人机系统具有较低的时延、多普勒频移以及变化速率。并对物理层、层二和层三的潜在影响提出解决方案，完善RAN架构和接口协议。就架构问题而言，TR38.821取代了TR38.811。 TR 28.808(R16)《Study on management and orchestration aspects with integrated satellite components in a 5G network》本研究旨在将卫星集成对现有5G网络业务模式、管理和业务流程的影响和复杂性降到最低。 除此之外，3GPP对卫星导航方面制定了相关技术规范，如TS 25.172、TS 25.173、TS 36.171、TS 38.171。在2019年3月发布的R15 TS 38.171《Requirements for support of Assisted Global Navigation Satellite System (A-GNSS)》报告中详细介绍了3GPP在卫星通信与5G融合中提出的要求，包括：①在信号比较弱的条件下，接收机的灵敏度要求；②在理想条件下，A-GNSS位置估计的精度要求，以确保位置估计的准确性；③动态距离要求的目的是确保当可见卫星具有相当不同的信号水平时，GNSS接收机性能良好；④接收机对多径的容忍度；⑤对于某些位置服务而言，移动场景和定期更新的目的是验证接收器产生GNSS测量或位置修正的能力，当它位于减速、转弯或加速的车辆上时，要具有良好的跟踪性能。 参考文献下载地址：https://www.3gpp.org/ftp/Specs/archive/","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[{"name":"5G","slug":"5G","permalink":"http://yoursite.com/tags/5G/"}],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"【吉他指弹】风居住的街道","slug":"风居住的街道","date":"2019-05-26T04:22:25.000Z","updated":"2020-10-13T14:30:53.668Z","comments":true,"path":"风居住的街道/","link":"","permalink":"http://yoursite.com/风居住的街道/","excerpt":"简介 风居住的街道，和室友来到了北京胡同（应“街道”二字( •̀ ω •́ )）取景，在烟袋斜街里一条安静的胡同录完视频，然后去后海吃吃吃，啊哈哈哈哈嗝 通过拍视频来更加了解这座城市，在这里留下印记，感觉是一件特别有意义的事情呢~","text":"简介 风居住的街道，和室友来到了北京胡同（应“街道”二字( •̀ ω •́ )）取景，在烟袋斜街里一条安静的胡同录完视频，然后去后海吃吃吃，啊哈哈哈哈嗝 通过拍视频来更加了解这座城市，在这里留下印记，感觉是一件特别有意义的事情呢~ 视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer14\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/fengJuZhuDeJieDao/fengJuZhuDeJieDao.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/fengJuZhuDeJieDao/fengJuZhuDeJieDao.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"【古典吉他】My Heart Will Go On","slug":"myHeartWillGoOn","date":"2019-04-14T15:27:35.000Z","updated":"2020-10-13T14:31:11.119Z","comments":true,"path":"myHeartWillGoOn/","link":"","permalink":"http://yoursite.com/myHeartWillGoOn/","excerpt":"简介 《泰坦尼克号》主题曲《My Heart Will Go On（我心永恒）》 The story is about disaster, brave, faith and the true love. You must promise me that you’ll survive. You jump, I jump. 真爱永恒。","text":"简介 《泰坦尼克号》主题曲《My Heart Will Go On（我心永恒）》 The story is about disaster, brave, faith and the true love. You must promise me that you’ll survive. You jump, I jump. 真爱永恒。 视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer6\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/myHeartWillGoOn/myHeartWillGoOn.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/myHeartWillGoOn/myHeartWillGoOn.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"LTE信道汇总","slug":"信道名称汇总","date":"2019-03-06T12:12:42.000Z","updated":"2019-10-06T15:41:49.702Z","comments":true,"path":"信道名称汇总/","link":"","permalink":"http://yoursite.com/信道名称汇总/","excerpt":"","text":"关系RLC-(逻辑信道)-&gt;MAC-(传输信道)-&gt;物理层-(物理信道) 映射关系图 逻辑信道下行(4个控制信道+1个业务信道) BCCH: 广播控制信道 Broadcast Control Channel PCCH: 寻呼控制信道 Paging Control Channel CCCH: 公共控制信道 Common Control Channel DCCH: 专用控制信道 Delicated Control Channel DTCH: 专用业务信道 Delicated traffic Channel（业务） 上行(是下行中信道的一部分) CCCH: 公共控制信道 Common Control Channel DCCH: 专用控制信道 Delicated Control Channel DTCH: 专用业务信道 Delicated Traffic Channel（业务） 传输信道下行 BCH: 广播信道 Broadcast Channel PCH: 寻呼信道 Paging Channel DL-SCH: 下行共享信道 Downlink Share Channel 上行 RACH: 随机接入信道 Random Access Channel UL-SCH: 上行共享信道 Uplink Share Channel 物理信道下行(4个控制信道+1个业务信道) PBCH: 物理广播信道 Physical Broadcast Channel基站广播终端UE接入系统所必需的关键系统信息，如下行带宽、PHICH的格式、天线端口数量等内容。这些内容称为MIB(主信息块，Master Information Block)注意：PBCH只广播系统最重要的信息，其他的系统信息通过PDSCH来传达。 PCFICH: 物理控制格式指示信道 Physical Control Format Indicator ChannelPCFICH把PBCH的内容又细分了一下，专门广播其中非常关键的子帧格式信息，这里说的子帧格式信息指的是一个子帧中可以用来承载下行控制信道的OFDM符号数目，也就是控制区的大小。承载的内容称为 CFI(格式控制指示，Control Format Indicator)。 PHICH: 物理HARQ指示信道 Physical Hybrid-ARQ Indicator Channel基站eNB使用PHICH向终端UE反馈与上行HARQ相关的ACK/NACK信息。承载的内容称为HI(HFARQ指示，HARQ Indicator) PDCCH: 物理下行控制信道 Physical Downlink Control Channel基站eNB使用PDCCH发送与业务调度相关的信息。比如，与下行方向上PDSCH相关的传输格式、资源分配、功率控制等信息。承载的内容称为 DCI(Donwlinl Control Information)。非常重要的概念。 PDSCH: 物理下行共享信道 Physical Downlink Shared Channel（业务） 上行(2个控制信道+1个业务信道) PRACH: 物理随机接入信道 Physical Random Access Channel用来通知基站(eNB)有终端(UE)需要接入。 PUCCH: 物理上行控制信道 Physical Uplink Control Channel用于发送与上行调度相关的信息，如调度请求（Scheduling Request , SR）、HARQ 反馈，以及信道状况信息（Channel Status Information ,CSI）。承载的内容称为UCI(Uplink Control Information) PUSCH: 物理上行共享信道 Physical Uplink Share Channel（业务）","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"http://yoursite.com/tags/LTE/"}],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"【吉他指弹】大鱼","slug":"大鱼","date":"2019-03-04T11:57:08.000Z","updated":"2020-10-13T14:31:32.618Z","comments":true,"path":"大鱼/","link":"","permalink":"http://yoursite.com/大鱼/","excerpt":"简介 椿去湫来，海棠花开。 你是否已化作人间的风雨，穿越时光来到这里。","text":"简介 椿去湫来，海棠花开。 你是否已化作人间的风雨，穿越时光来到这里。 视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer9\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/daYu/daYu.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/daYu/daYu.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"留言板","slug":"bbs","date":"2019-02-28T11:43:10.000Z","updated":"2019-02-28T13:26:32.605Z","comments":true,"path":"bbs/","link":"","permalink":"http://yoursite.com/bbs/","excerpt":"","text":"欢迎留下你的足迹！点开留言板在评论区随便说点什么吧~","categories":[],"tags":[{"name":"留言板","slug":"留言板","permalink":"http://yoursite.com/tags/留言板/"}],"keywords":[]},{"title":"Pr学习笔记","slug":"Pr学习笔记","date":"2019-02-28T08:37:54.000Z","updated":"2019-02-28T15:10:06.587Z","comments":true,"path":"Pr学习笔记/","link":"","permalink":"http://yoursite.com/Pr学习笔记/","excerpt":"Pr入门 学习视频剪辑，强烈推荐doyoudo。教学内容包含Adobe公司的常见软件PR、PS、AE等，还有一些常用的音乐软件Cubase、Fl studio等。教学逻辑清晰，丝毫不拖泥带水。分分钟带你入门视频剪辑。视频剪辑真的是一件特别有趣的事情，掌握了这个技能，乐趣多多，快来一起玩吧！","text":"Pr入门 学习视频剪辑，强烈推荐doyoudo。教学内容包含Adobe公司的常见软件PR、PS、AE等，还有一些常用的音乐软件Cubase、Fl studio等。教学逻辑清晰，丝毫不拖泥带水。分分钟带你入门视频剪辑。视频剪辑真的是一件特别有趣的事情，掌握了这个技能，乐趣多多，快来一起玩吧！ 本系列视频分为8集。第一集为介绍，后七集为教程。话不多说，附上B站链接吧！建议直接在B站内打开收藏。 教程列表 1/7新建你的第一个工程 2/7如何导入视频音频图片素材 3/7拿起剪刀，开始咔嚓你的影片 4/7如何给视频加特效 5/7如何添加配乐 6/7如何添加字幕、标题 7/7导出又小又清晰的影片 这系列的视频是非常基础的，学会可以完成一些基本的操作啦！更多进阶教程探索doyoudo吧！ Premiere软件下载 此安装包为Adobe Premiere Pro CC 2015版本。拿出压箱底珍藏的软件分享给有需要的人，以供学习交流，不可用于商业用途。内附安装教程、注册机。祝学习愉快！链接：https://pan.baidu.com/s/1a77DO6ujoRDa9gbjAgymIQ提取码：noqk Photoshop软件下载 此安装包为Adobe Photoshop CC 2015版本。链接：https://pan.baidu.com/s/1R_QOOiAmc9FHBd-EQjbe_w提取码：56vq","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[{"name":"Pr","slug":"Pr","permalink":"http://yoursite.com/tags/Pr/"}],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"【Vlog】我的周末日常","slug":"我的周末","date":"2019-02-24T15:01:31.000Z","updated":"2019-05-22T07:53:48.415Z","comments":true,"path":"我的周末/","link":"","permalink":"http://yoursite.com/我的周末/","excerpt":"简介 第一次做Vlog, 来记录研究生这半年的生活。这其实是我大部分周末的一个缩影，用这种形式来记录一下吧。每一个日子，简单但不平凡。自己的小目标，都在一个个慢慢实现。就是干咯！ヾ(•ω•`)o","text":"简介 第一次做Vlog, 来记录研究生这半年的生活。这其实是我大部分周末的一个缩影，用这种形式来记录一下吧。每一个日子，简单但不平凡。自己的小目标，都在一个个慢慢实现。就是干咯！ヾ(•ω•`)o 视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer13\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/vlog/vlog.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"vlog","slug":"vlog","permalink":"http://yoursite.com/tags/vlog/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"【吉他指弹】未闻花名","slug":"未闻花名","date":"2019-02-14T14:16:48.000Z","updated":"2020-10-13T14:33:04.792Z","comments":true,"path":"未闻花名/","link":"","permalink":"http://yoursite.com/未闻花名/","excerpt":"简介 《未闻花名》是一个讲述友情的感人动漫，剧中恰到好处插入的同名主题曲赚足了眼泪。本吉他指弹版本改编自uBio。风和时间一起飘过，我相信我们还能再相遇。","text":"简介 《未闻花名》是一个讲述友情的感人动漫，剧中恰到好处插入的同名主题曲赚足了眼泪。本吉他指弹版本改编自uBio。风和时间一起飘过，我相信我们还能再相遇。 吉他演奏视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer12\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/weiWenHuaMing/weiWenHuaMing.mp4\",\"pic\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E9%97%BB%E8%8A%B1%E5%90%8D%E8%A7%86%E9%A2%91%E5%B0%81%E9%9D%A2.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 教程潇潇指弹教学视频良心教学，实力推荐。教学视频一共分了三个部分，祝大家练琴愉快~ 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"【吉他指弹】yesterdayOnceMore","slug":"yesterdayOnceMore","date":"2019-02-14T14:16:20.000Z","updated":"2020-10-13T14:32:47.168Z","comments":true,"path":"yesterdayOnceMore/","link":"","permalink":"http://yoursite.com/yesterdayOnceMore/","excerpt":"简介 这是岸部真明一首特别经典的指弹曲，改编自卡朋特的一首经典金曲《Yesterday Once More》，中文名为《昨日重现》。以后听到自己弹过的曲子，应该会回忆起曾经那些练琴的夜晚吧。","text":"简介 这是岸部真明一首特别经典的指弹曲，改编自卡朋特的一首经典金曲《Yesterday Once More》，中文名为《昨日重现》。以后听到自己弹过的曲子，应该会回忆起曾经那些练琴的夜晚吧。 吉他演奏视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer7\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/yesterdayOnceMore/yesterdayOnceMore.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"【吉他指弹】1967","slug":"1967","date":"2019-02-14T14:12:49.000Z","updated":"2020-10-13T14:32:13.537Z","comments":true,"path":"1967/","link":"","permalink":"http://yoursite.com/1967/","excerpt":"简介 1967这个曲子听着很舒服啊，原曲为双吉他版本，本视频为改编后的单吉他版。 这是我入了古典吉他坑之后学的第一首曲子，也是第一次自己制作视频。还有很多值得改进的地方，慢慢来吧。嘻嘻。PS：末尾两个彩蛋233333，特别鸣谢龙小黑童靴友情出演。","text":"简介 1967这个曲子听着很舒服啊，原曲为双吉他版本，本视频为改编后的单吉他版。 这是我入了古典吉他坑之后学的第一首曲子，也是第一次自己制作视频。还有很多值得改进的地方，慢慢来吧。嘻嘻。PS：末尾两个彩蛋233333，特别鸣谢龙小黑童靴友情出演。 (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/1967/1967.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 吉他演奏视频 音频 吉他谱（单吉他版本） 注意事项《1967》单吉他版，标准调弦，2品。备注：16小节括号的两个音，我分别弹得5弦2品，和4弦2品。感觉更好听一些。 最后一个小节的后两个音我弹的泛音。可参看视频嘿嘿，瞎玩。关于重复符号的看法：重复符号有两对。第一对是第2小节的开始、9的结尾。第二对是11的开始、26的结束。先讲第一对重复符号：我们从第一小节开始弹琴1-9，弹完第9小节遇到重复符号的结尾，就跳转到该重复对的起始，即2小节，也就是说弹完第九节弹第二节。然后继续往下走开始第二遍，走走走，弹完第8小节，跳到第10小节。因为第9小节上面标了一个1，第10小节上面标了一个2，代表第一遍弹9节，第二遍弹10节。至此，第一对重复符号走完了。第二对：顺着刚才弹第10小节后，一直往后弹完26小节，遇到重复符号，跳转到这一对的开始，也就是弹完26，弹11。往后弹，弹完17，弹27（因为这是第二遍，走27。刚才第一遍走的18），一直到最后。 封面","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"【吉他指弹】愿樱","slug":"愿樱","date":"2019-02-11T02:53:22.000Z","updated":"2020-10-13T14:45:15.480Z","comments":true,"path":"愿樱/","link":"","permalink":"http://yoursite.com/愿樱/","excerpt":"简介 这首曲子是我和好朋友若水清风的第一次合作。愿樱曲风凄美，遂有感将秒五片段加到作品中。视频中加入了一些鸟声等特效，意在渲染当时的演奏场景。末尾作词是自己对秒五中主人公故事的一些理解，也是对现在分离在五湖四海的大学同学的怀念。取景地选于我的母校郑州大学，作为毕业留念。","text":"简介 这首曲子是我和好朋友若水清风的第一次合作。愿樱曲风凄美，遂有感将秒五片段加到作品中。视频中加入了一些鸟声等特效，意在渲染当时的演奏场景。末尾作词是自己对秒五中主人公故事的一些理解，也是对现在分离在五湖四海的大学同学的怀念。取景地选于我的母校郑州大学，作为毕业留念。 吉他演奏视频(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer11\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"https://hexofile.oss-cn-beijing.aliyuncs.com/yuanYing/yuanYing.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 音频 吉他谱","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"【吉他指弹】十里花道","slug":"十里花道","date":"2019-02-11T02:09:47.000Z","updated":"2019-03-04T12:51:50.025Z","comments":true,"path":"十里花道/","link":"","permalink":"http://yoursite.com/十里花道/","excerpt":"简介 在琴房学琴的时候，每次都会先练习这个练手。曲子简单但旋律优美。","text":"简介 在琴房学琴的时候，每次都会先练习这个练手。曲子简单但旋律优美。 吉他演奏视频点这里 音频 吉他谱","categories":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/tags/吉他/"}],"keywords":[{"name":"吉他","slug":"吉他","permalink":"http://yoursite.com/categories/吉他/"}]},{"title":"hexo使用笔记（持续更新）","slug":"hexo使用笔记（持续更新）","date":"2019-02-09T12:12:42.000Z","updated":"2019-03-04T13:36:21.130Z","comments":true,"path":"hexo使用笔记（持续更新）/","link":"","permalink":"http://yoursite.com/hexo使用笔记（持续更新）/","excerpt":"","text":"hexo搭建指南教程：使用hexo+github搭建免费个人博客详细教程结合hexo在GitHub上搭建个人博客——全过程两个教程搭配食用，口感更加。 Markdown 语法教程教程：最实用的 Markdown 语法教程 如何添加pdf功能教程：GitHub中Hexo next主题下搭建的博客中增加PDF插件注意事项：hexo-pdf安装包需要放在博客安装目录下。就我们平时输入hexo g,hexo s,hexo d 那个路径下命令行输入。后面再需要安装别的插件时，也是这个路径。 如何添加评论功能教程：在Hexo博客的next主题中启用Valine评论 评论功能如何设置邮件提醒这个功能是非常的实用。功能：有了新评论提醒站长，评论有回复了提醒楼主。教程：hexo博客添加Valine评论系统教程：Valine Admin官方文档 如何添加视频尝试了几种，如下：B站自带: 不用安装任何插件。颜值略逊一筹，界面有点繁琐。但是如果你是一个B站up主，使用时就可以很省事地直接调用外链，将代码复制到需要的地方。教程：从bilibili引用视频默认的格式有点小，可以再加一些参数，比如我的，最后三个参数是自己加的。123&lt;iframe src=\"//player.bilibili.com/player.html?aid=38249542&amp;cid=67264830&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" height=\"560\" width=\"1024\" quality=\"high\"&gt; &lt;/iframe&gt; dplayer: 颜值超高，传送门这不就是我理想中的web播放器么，简洁美观。说干就干，装上再说。同样也是一句命令就可以搞定！教程：hexo-tag-dplayer 使用过程中，走过一点弯路，总结下来。dplayer播放器的视频来源有两种：一种是本地视频直接访问，另外一种是网页链接（将视频上传到云，然后获取外链）。 一开始由于还没有研究云，先选择了本地访问，然后问题就出现了。首先由于我的网站是托管在GitHub上，单个文件最大不能超过100M。这导致我在将视频上传到网站时，频频被拒绝。后来将视频压缩至了100M以内，上传非常慢，不符合我建设这个轻量级博客的初衷。 乖乖去七牛云注册并实名验证后，就可以获得免费的10G空间啦，然后选择 管理控制台-&gt;对象存储-&gt;新建存储空间 ，来上传到云，速度非常快，使用时获取外链就可以。 多说一句，七牛云要求用户必须绑定域名，否则只能使用一个月，基于此，申请一个域名（且备案）的需求就产生了。但是我的域名没有备案，所以最后我用了阿里云OSS（一年9块）。 总之，最后选择了dplayer+阿里云OSS，毕竟dplayer颜值杠杠的！ 我现在已经将所有的资源全放在OSS（视频、音频、pdf谱子、图片等）上，搭配阿里云客户端，炒鸡好用。 如何添加音频网易云自带:不用安装任何插件。直接在网易云调用外链,将代码复制到需要的地方就行。教程：Hexo Next主题嵌入网易云音乐aplayer:有些音频没有版权，可以采用这种方式。该插件和 dplayer 师出同门。界面简洁大方。教程：Hexo博客中插入音乐注意事项：我是将音频MP3文件和专辑封面放在了阿里云OSS上，获取外链调用。注意最后一个参数，如果想自动播放就加上 autoplay，不想自动播放就去掉这个参数。而不是设置=1或者=0，否则报错。123&#123;% aplayer \"風の詩\" \"押尾コータロー\" \"https://hexofile.oss-cn-beijing.aliyuncs.com/%E6%8A%BC%E5%B0%BE%E3%82%B3%E3%83%BC%E3%82%BF%E3%83%AD%E3%83%BC%20-%20%E9%A2%A8%E3%81%AE%E8%A9%A9.mp3\" \"https://hexofile.oss-cn-beijing.aliyuncs.com/%E9%A3%8E%E4%B9%8B%E8%AF%97.jpg\" \"autoplay\" %&#125; 如何拥有一个域名完成这一步，当别人输入你申请的域名，比如我的是 www.longyating.com ，输入这个网址就可以访问我的网站啦！ 1.申请域名我的域名是在阿里云买的。新用户优惠通道(仅限注册后的两日内)我花了25元买到了.com一年的使用权。购买过程需要完成实名认证操作，整个过程挺快的，不出两个小时就拥有了一个属于自己的域名。教程：通用域名注册流程 2.绑定网站买了域名，怎样把它指向你建好的网站呢。教程：使用github-hexo-域名绑定（阿里云）搭建个人博客 如何添加不带评论区的about/留言板页面每个主题不太一样，教程针对snippet主题。①在命令行输入，hexo new page about 。会发现source多出一个about文件夹的index.md文件。编辑即可。about这个名字就是不一般的。②新增menu菜单的选项卡。这里的about要和在主题的_config.yml文件中的menu中进行匹配如：menu:Home: /Archives: /archivesAbout: /about 注意这是新增的③hexo d -g 部署即可。 同理，留言板是 hexo new page guestbook，再menu新增选项卡即可。注意事项：我用的这个主题，这样方式新增的没有评论区。那如果想带评论区怎么办呢？参考下面这种方式。 如何添加带评论区的about/留言板页面每个主题不太一样，教程针对snippet主题。①hexo new page “bbs”。和普通的md文件的新建方式是一样的。bbs是留言板的英文名，之所以不使用中文，是因为乱码看着不方便。②hexo d发布③修改主题的_config.yml文件的menu，新增留言板选项卡。将留言板的url指向你刚刚新建并发布的bbs的网页地址，注意不是localhost:4000的地址。比如我的是：menu: page: 留言板url: https://www.longyating.com/bbs/","categories":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}],"tags":[{"name":"网站搭建","slug":"网站搭建","permalink":"http://yoursite.com/tags/网站搭建/"}],"keywords":[{"name":"充电学习","slug":"充电学习","permalink":"http://yoursite.com/categories/充电学习/"}]},{"title":"【读书笔记】富兰克林自传","slug":"富兰克林自传","date":"2019-02-09T10:09:13.000Z","updated":"2020-10-13T13:51:33.219Z","comments":true,"path":"富兰克林自传/","link":"","permalink":"http://yoursite.com/富兰克林自传/","excerpt":"","text":"在我的一生中，能让我佩服的人有三位：第一位是本杰明·富兰克林，第二位也是本杰明·富兰克林，第三位还是本杰明·富兰克林。——乔治·华盛顿（美国第一任总统） 富兰克林，一个来自贫困家庭，却发展成难以置信的通才。他是政治家，外交家，科学家，哲学家，发明家，文学家，慈善家。参加起草了《独立宣言》与《美国宪法》，是美国历史上一位不可或缺的伟大人物。然而他的墓碑上却刻着，印刷工富兰克林。他的《富兰克林自传》这本书中，富兰克林以拉家常的方式把自己成功的经验和失败的教训娓娓道来。整部自传在通俗易懂的叙述中，不时会有睿智和哲理的火花。通过这本书则可以与他进行伟大心灵的对话。 关于读书学习： 富兰克林从小就爱读书，把手上的零花钱都花在读书上。12岁就在印刷厂打工的富兰克林，通过给自己创造读书机会，读完了《天路历程》等书，书中的很多内容为他的思想形成，以及人生中的很多重要决策起到了关键影响。通过与印刷业的便利，富兰克林与书铺的书徒们打上交道，他会经常在夜晚去找这些学徒们借书，为了避免别人发现影响书籍的销售，所以借来的数必须在第二天清晨归还。所以富兰克林便开始了白天做工，晚上便读书到深夜。长大后的富兰克林，每天都要抽出一两个小时来读书，他想通过这样来弥补自己没有受过高深教育的缺陷。除了读书之外，富兰克林几乎不允许自己有其他的娱乐，他从不到酒馆赌场或者任何其他娱乐场所去消磨时光。即使长大后境遇逐渐好转，他也依然保持着勤俭朴素的生活。在富兰克林眼中，勤奋和节俭是发财和成名的唯一手段。 关于为人修养 在自传中最值得一提到的是他记录的十三美德。富兰克林将自己需要培养的美德归入十三个条目，每一个名目附上一条简短的规戒，充分表达所定义的范围。他将这十三美德称为影响他一生的伟大计划。这些美德名目及其规戒是： 一，节制。食不过饱，酒不过量。 二，缄默。于人于己不利的话不谈。避免碎语闲言。 三，秩序。放东西各归其位，办事情各按其时。 四，决心。决心去做该做的事情，做就做到心想事成。 五，节俭。不花于己于人没有好处的闲钱，杜绝浪费。 六，勤奋。珍惜时光。手里总忙有益之事。剪除一切无谓之举。 七，诚信。不害人，不欺诈。 思想坦荡，公正；说话实事求是。 八，正义。不损人利己，伤天害理的行为永不沾边，利公利民的应尽义务切勿放手。 九，中庸。避免走极端。忍让化冤仇。 十，清洁。身体、衣着、居所，不许不干不净。 十一，平静。不可为小事、常事或难免之事搅乱了方寸。 十二，贞洁。除非为保健康，延子嗣，应该注意节欲。千万不可搞得精神萎靡，身体虚弱，或者伤害自己或他人的平静或声誉。 十三，谦卑。效法耶稣和苏格拉底。 我的意图是把这些美德养成习惯，所以我认为最好不要同时全面开花，分散了注意力，而应当一次专注于一项，等把这一项掌握透了，然后再试下一项，这样循序渐进，直到我把十三项统统做到。由于先养成几项可以方便另外几项的养成，于是我根据这种看法按它们上面的地位做了安排。节制先行，因为它有助于头脑冷静，思维清晰，这在常备不懈高度警惕、防范旧习持续的吸引、抵御强大永久的诱惑的地方是不可或缺的。这一项养成巩固之后，缄默就更容易做到了，由于我的愿望是提高美德和获取知识齐头并进，考虑到谈话中，获取知识靠的是耳朵听，而不是嘴巴讲，因此就希望破除我正在养成的唠唠叨叨耍嘴皮子的习惯，因为这种习惯只能使我与轻嘴薄舌之徒为伍，所以我把缄默放在第二位。这一项和下一项秩序，我希望会使我有更多的时间关照我的计划和我的学习；决心一旦变成习惯，将会使我坚定不移地努力获取随后的所有美德；节俭和勤奋，由于使我摆脱了剩下的债务，获得了独立和富裕，所以使我更容易实施诚信和正义。由于当时认为，按照毕达哥拉斯《黄金诗》里的忠告，每日自查不可或缺，我便想出下列办法进行自查。 我订了一个小本子，一项美德占一页。每一页用红笔画上竖线，形成七行，一行代表一周中的一天，每天用一个字表示。再用红笔画十三条横线，与七条竖栏交叉，每一条横线的开头写上一项美德的头一个字，每天在自查中发现哪项美德方面一有过错，就在相应的竖栏中的横线上画一个小黑点．我决心一周对一项美德严密监视，依次执行。这样第一周我就严防死守，对节制不可有丝毫的触犯，别的美德就顺其自然了。只是每天晚上标出当天的过错。这样，如果第一个礼拜我能使标明“节制”的第一条线没有黑点，我就认为那一项美德的习惯大大加强，它的对立面削弱了，因此我可以放心大胆地把注意力延伸，把下面一项也包括进去，争取下礼拜两条线上都没有黑点。就这样逐一进行，直到最后一项，我可以在十三周之内走完全程，一年四个流程。就像一个人给花园锄草，他就没有打算一下子把所有的莠草铲尽锄绝，因为他没有这个能耐，但他可以一次锄一畦，锄完第一畦，再锄第二畦；所以我由于从本子上看到线上的黑点连续清除表明我在美德修养上取得了进步，从而应当感到（我希望）欢欣鼓舞，最后，经过几个流程，经过十二个礼拜的天天查，我看到的是一本干干净净没有黑点子的本子，我感到由衷地高兴。 我在这个小本子上抄写了艾狄生《卡托》里的几行诗作为题词： 在这里我愿意相信：如果我们头上有一种神力，他肯定会对美德格外喜欢， 而且他喜欢的对象也一定快活。","categories":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}],"tags":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/tags/随笔杂记/"}],"keywords":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}]},{"title":"【读书笔记】《人间失格》——太宰治","slug":"人间失格","date":"2019-02-06T15:11:03.000Z","updated":"2020-10-13T13:52:24.097Z","comments":true,"path":"人间失格/","link":"","permalink":"http://yoursite.com/人间失格/","excerpt":"","text":"若能避开猛烈的欢喜，自然也不会有悲痛来袭。 这本书读下来给人的感觉很丧，主人公叶藏讲述了自己一生耻辱的生活。叶藏出身于一个殷实的家庭，父亲是日本议员，在家中年龄最小，是公认的帅气美男子。年幼时，叶藏受到家中佣人的侵犯。叶藏说，是他们让我体会到世上的悲哀之事。我至今依然认为，对幼小孩童做出此等行径，是人类罪行中最为丑陋、低级且残酷的。若我惯于讲实话，也许能理直气壮地将他们的罪行告诉父母，但我对自己的亲生父亲也不全然了解。我认为向人诉说不过是徒劳，与其如此，不如默默承受。 叶藏在班里故意出丑，来赢得大家的开心，用可悲的滑稽戏码逗笑他人。竹一看穿一切，私下指出叶藏是个妖怪。其实叶藏一直在演戏，他把这称为“丑角精神”，他决定把真实的自己画下来。那是一副阴森凄惨、令人毛骨悚然的小黑人。表面上的叶藏性格开朗，逗人发笑，实则有一颗如此阴郁的心。 长大后，叶藏来到东京上学。与朋友堀木在同一家画室学习画画，但两人不务正业，嗜酒，嫖娼。生活奢侈，囊中羞涩。私下参加地下党组织被警察发现，逃跑路上遇到了酒吧女恒子，恒子帮助他躲过了警察（虽然后来还是被发现），两人关系升温。觉得世道太乱，相约一起跳海，结果，恒子死了，叶藏被救。镰仓跳海事件被媒体曝光，叶藏涉嫌协助自杀罪。父亲担心叶藏影响自己职业生涯，将叶藏送到偏远的一个地方，被关在屋子里，他经常看到他画的那只黑色妖怪出现。 叶藏逃了出来，去找损友堀木，遇到了静子，静子在一家报社记者，堀木为其报纸作画。静子有一个5岁的女儿，名叫茂子。而后，叶藏过上了小白脸的生活，与静子和茂子生活在一起。为报社画一些儿童漫画，但收入卑微。叶藏暗自思忖，一定要离开这个女人，自力更生。茂子说，“我想要一个真正的爸爸。”这句话，对叶藏杀伤力十足，他看到那只妖怪又出来了，叶藏惊慌而逃。有一天，叶藏决定不再打扰她母女两人的生活，离开了这里。 叶藏借住在京桥附近一家小酒吧的二楼，老板娘收留了他，再次过上小白脸的生活。这段时间他遇到了酒吧对面小香烟铺的女儿，十七八岁，叫祝子。祝子少不更事，单纯善良，拥有一颗纯真的信赖之心。白皙的梁上闪现的是不曾见过丑恶的童贞。叶藏向他坦白了他所有的罪过，但祝子却微笑着说他爱开玩笑。叶藏做了一个决定，如果祝子答应嫁给他，他就戒酒，并和她骑自行车去青叶看瀑布。他对祝子说，救救我吧，求你了。叶藏与祝子结婚了，叶藏努力画画，迄今为止，他从来没有为了一个人如此努力过。 就在日子简单美好的时候，堀木又来了。即将忘却的时候，却飞来一只怪鸟，用喙啄破我的伤口。过往的可耻和罪恶的记忆转瞬间在眼前浮现。 “去喝一杯吧。”叶藏说。（虽然之前答应祝子戒酒） 一个闷热的夏日夜晚，堀木来找叶藏，为了借钱。祝子在煮蚕豆，堀木叶藏二人坐在屋顶玩猜词游戏，言语之中，原来堀木并没有把叶藏当成一个真正的人，仅仅是一个行尸走肉的怪物，堀木的话刺伤了叶藏。思及此，叶藏十分低落。转念一想，我从小就是一个不配为人的孩子，堀木如此看我，也无可厚非，于是装作无关痛痒的样子。 堀木下楼去端蚕豆，却发现了祝子被一个男人侵犯了。侵犯祝子的，是那个请我画画的商人。哪怕那个矮个子商人与祝子之间有一丝类似爱情的东西，我都能好受些。但是那个夏夜，祝子轻信于他，感情仅限于此。我对唯一能救赎自己的品质产生了一疑惑。我越发难以理解世间的一切，终于回到了只有酒精的日子。两人关系再也回不到从前。 一天晚上，叶藏发现祝子偷偷起身，准备复用安眠药，叶藏像个疯子一样，抢过了药，大口大口地全部吞了下去。叶藏被救过来后，说，“请让我和祝子离婚吧。” “我要去一个没有女人的地方。”之后叶藏染上了毒品，身体状况每况愈下，咳血。他们把叶藏送上汽车，去往森林深处疗养，这里所有人都是男的，就连护士也是，当时的呓语一语成谶。而这里，原来是一家精神病院。 叶藏向神发问：“不反抗何罪之有？”此刻，叶藏的额头刻上了疯子的印记，不，是废人的印记。 我丧失了做人的资格。 叶藏从精神病院里逃出来，他来到一家诡异的店里，向老板娘要了一点减轻痛苦的药。最后，他和妖怪坐在火炉两侧，永远地和他呆在了一起。 以下影评来自木鱼水心： 作品塑造了叶藏这样一个沉迷在内心深处无法自拔，却让人印象深刻的角色。但后期的叶藏多少有一些抑郁倾向，想得太多，行动太少，一旦行动起来，便感觉有无边的压力袭来。他从小了解人类的种种卑劣之处，对这种卑劣深深厌恶，但他随后发现自己身上也有这种卑劣，进而也对自己产生了深深的厌恶。但是，叶藏并没有力量去阻止，甚至没有力量去努力，只好随波逐流，做一个被动的人。为了脱离这种罪恶感，他的精神领域里产生了一种自我切割的现象，把这些卑劣，具现化成了那个黑色的小人。那个小人，可以说是叶藏自己的罪，但也可以说是叶藏自己，一般人，是终生和小人共生下去的。但叶藏对于内心世界有着很高的追求，希望把这件事情思考透彻。所以最后只好陷入了极端，选择放弃自己的生命。 其实，了解到人性本恶这一点，其实不一定要走向这样的极端。不如放弃掉对人性的虚假预期，想着怎样在每件事情上努力变好，可能是更积极的做法。不过，人并不能总是这么坚强与阳光，所以，叶藏取得读者的共鸣与同情。因为很多人都曾经尝试过像叶藏这样思考，只是，最后不一定会选择这么极端的方式。希望读者在看完这部作品之后，是有“别人也有同样经历，能够理解自己”的治愈。而不要在这种厌恶的情绪中继续发展。叶藏纤细而罪恶的灵魂，因为他本身的自我反省和罪恶感。连同他诚实和不愿意伤害别人的出发点，具有一种值得称颂的价值。这也是最后说“如同神一样的好孩子”的原因。无论如何，人的生命宝贵，千万要珍惜。人性不美好，却正是我们每天努力的价值。 黑夜给了我黑色的眼睛，我却用它去寻找光明。","categories":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}],"tags":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/tags/随笔杂记/"}],"keywords":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}]},{"title":"【随笔】关于自律","slug":"关于自律","date":"2019-02-06T15:10:02.000Z","updated":"2020-10-13T13:51:46.276Z","comments":true,"path":"关于自律/","link":"","permalink":"http://yoursite.com/关于自律/","excerpt":"","text":"“我们想变得和别人不一样，每天却在做着和别人一样的事情。” 这是我一直很想写的一篇文章。今天有机会来聊聊，发表下自己的看法。 对于现在正处于性格养成最关键的青年时期而言，自律是非常值得培养的习惯，一旦养成，会给我们带来很多好处。 我们的每个人底子中都有惰性，它总是在生活中猝不及防地出现。比如，一个昨晚励志早起的早晨，立下的健身flag，一个本来打算看书的周末。取而代之的，是被拖延的课程任务，肚子上的肥肉，和打完游戏的空虚。这样的情形每个人都经历过。每每如此，我都会有放纵自己之后深深的愧疚感。我们想变得和别人不一样，每天却在做着和别人一样的事情。 拖延症是生活中的绊脚石，学会利用deadline。最近干的一件蠢事，让我思考这个问题。一门网课结课了，明明有一周的答题时间，非要拖到最后一天，又由于记错时间，结果就是愚蠢地错过了期末考试，导致重修。所幸是一门网课，不会有挂科记录，但是代价是要重刷一遍，浪费时间事倍功半。因为网络崩溃，或其他不可控因素导致任务没有完成的事情在我们生活中屡见不鲜。自己总是把事情拖到最后时刻，在作死的边缘试探，风险代价可想而知。在《专注力》这本书中说，如果你是那种事情拖到最后时刻能效率特别高，而且也能完成的很好的那种，这不算拖延症，大可继续保持这种行为习惯。其实我发现支持我拖延的原因正是最后效率特高。但不幸的是，由于总是会有各种各样的突发状况，导致事情在deadline到来的之前，完成的很仓促。于是经过几次教训之后，既然还是想要deadline逼着的高效率，中和之策就是把自己的deadline提前一天，留出一点余地给突发状况。 低质量的社交不如高质量的独处。看过很多类似于这样的文章，作者的观点我很认可。拒绝一些无用社交，远离负能量的圈子。留出一些时间给自己，热爱并且享受独处。认真对待生活中的一件件事。要么不做，要么做到最好。所谓的做的最好，不是和别人比，更大意义上是自己全力以赴，尽己所能。 世界上最厉害的人，是说起床就起床，说睡觉就睡觉，说做事就做事，说玩就玩，说收心就收心。这样的人，他们总是可以经得起各种诱惑，而专注于自己生活中重要的事情。生活中要是能碰到这种朋友，何其幸运，我也总是会多多关注他的行为处事习惯来鞭策自己。 我观察了我身边一些令人欣赏的人，他们有着一种共性就是。“定目标，沉住气，悄悄干”。我曾在我考研期间租的小屋子，把这九个字贴在墙上。这给了我很大的精神帮助，最后也成功上岸。目标一旦定下，只要你认为它是正确的，是值得我们去花时间的，那就应该戒掉各种诱惑，全力以赴去执行。而其中的“悄悄干”，是最难的，也是我们应该重点去关注的。我观察身边很优秀的人，在一件事情没有最终做出来之前，是非常的保守。不会因为有了一点点小小的进展，就得意嚷嚷，把自己的想法告诉别人。于我而言，如果在有了一点点成就之后，就忍不住向别人炫耀。大多数情况下，就会沉浸在这种短浅的满足感中，得到一种完成最终目标的假象，随后失去了继续努力的动力，兴致也慢慢消退。包括定目标立flag，也不要轻易把自己的想法告诉别人，除非这能对自己起到督促作用。我们应该做的，就是悄悄地去努力积蓄能量，剩下的交给时间。 共勉。 (〃’▽’〃)","categories":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}],"tags":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/tags/随笔杂记/"}],"keywords":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}]},{"title":"【读书笔记】《挪威的森林》——村上春树","slug":"挪威的森林","date":"2019-02-06T15:09:04.000Z","updated":"2020-10-13T13:52:15.759Z","comments":true,"path":"挪威的森林/","link":"","permalink":"http://yoursite.com/挪威的森林/","excerpt":"","text":"只有自己才能将你救赎。渡边和直子共同的重要朋友的自杀两个人在冥冥之中有类似于精神支柱的感觉。自杀真的是一种很自私的行为。美丽温柔的直子同心魔抗争让人心疼最后却也难逃其手。渡边最后穿越了那片无边的沼泽和阴暗的森林他的活着，也被赋予某种使命，摸索新的世界。 三观一直在崩塌又在一点点重建。唯一让我感到希望的是直子坚强地同命运做抗争。可是最后却也难逃厄运。于渡边而言，身边的人一个个离他而去。喜欢玲子信里对渡边说的那句话“尽管你可能心里难受，但也还是要坚强起来，要再成熟一些，成为大人。” PS：这个书是带给我心灵冲击非常大一本好作品。由于此书情节跌宕起伏，特别容易使人沉迷，无法自拔，看不完就无法静心学习（反正我是这个死样子( • ̀ω•́ )✧），适合假期阅读。","categories":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}],"tags":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/tags/随笔杂记/"}],"keywords":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}]},{"title":"【读书笔记】《摆渡人》——克莱儿·麦克福尔","slug":"摆渡人","date":"2019-02-06T15:07:57.000Z","updated":"2020-10-13T13:52:09.104Z","comments":true,"path":"摆渡人/","link":"","permalink":"http://yoursite.com/摆渡人/","excerpt":"","text":"“为了再次拥有这份感受，值得冒永远沉沦的风险吗？ ”“值得。” 迪伦是个15岁的女孩，单亲和妈妈住在一起，话很少。最好的朋友也转学离开了。这天，她决定乘坐火车去见她未曾谋面的父亲。却不料，火车在穿过隧道时出了事故。醒来后，以为自己是唯一的幸存者，她看到一个小男孩坐在路堤。后来发现，原来她已经死了，而这个小男孩是她的摆渡人，叫崔斯坦。他的职责是给她引路到天堂，要穿过被称为荒原的地方才能到达。这个荒原是迪伦的心理影像，一路危险重重，偶尔也会景色迷人。 他们并肩作战，历经险阻终于到达天堂，这一路上两个人产生了感情。崔斯坦安全将迪伦送到天堂后，为了重新见到他的摆渡人崔斯坦，义无反顾一个人回到那险象重重的荒原寻找他，于是他们再次相遇。 在迪伦一再坚持下，他们冒险尝试回到现实，这违背常理，却只能背水一战。在遇到迪伦后，崔斯坦的身体也慢慢发生了变化，他不再是一束光，而是活生生的有了感情的人。他已经摆渡够了足够的灵魂，他也要有属于他自己的人生。穿回到现实的迪伦苏醒，却不见了崔斯坦。身体的伤痛无足轻重，内心绝望到疯狂。她被抬出了隧道，就在此时，她看到了他，像第一次那样坐在路堤上，风吹乱他浅茶色头发。 “原来你在这里” “我在这里” PS：这本书是一本治愈系的书，信息量不是很大，没几个小时就可以读完。内容小清新，适合打发时间时阅读。","categories":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}],"tags":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/tags/随笔杂记/"}],"keywords":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}]},{"title":"【读书笔记】《人生的智慧》——叔本华","slug":"人生的智慧","date":"2019-02-06T14:51:44.000Z","updated":"2020-10-13T13:52:31.090Z","comments":true,"path":"人生的智慧/","link":"","permalink":"http://yoursite.com/人生的智慧/","excerpt":"","text":"人所能获得的最大的幸运， 唯有自身的个性。 每当我独处的时候，就会思考人生的意义是什么？每日忙碌对我最重要的又是什么？久思未果，于是在书中寻找答案。《人生的智慧》是德国哲学家叔本华的经典作品。 叔本华将其决定人命运的根本差异分为三类，即：1. 人的自身 也就是最广泛的人的个性所具有的东西。包括人的健康、力量、外貌、气质、道德品格、精神智力以及潜能。 2. 人所拥有的身外之物 也就是人的财产和其他占有物。 3. 人对他人显示出的形象 可以理解为人在他人眼中所呈现的样子，也就是他人对这个人的看法。这种他人的看法包括名誉、地位和名望。 对人的幸福来说，最关键的是人的主体的优良素质，包括高贵的品格、出色的智力、快乐的性格和健康的身体——总而言之，就是“健康的身体和健康的灵魂”。歌德曾说： 众生，无论富贵还是贫贱， 都要承认： 人所能获得的最大的幸运， 唯有自身的个性。 人的健康之于其他一切外在好处都具有压倒性优势，健康的乞丐甚至要比生病的国王更加幸运。由于与财产和他人的看法相比，人的自身拥有更大的优势，所以比起拼命获取财富来说，注重身体健康和充分发挥自身才能是更为明智的。但是要避免对这一点的错误理解：我们不需要重视生活的必需品。那些所谓的真正的财富，也就是超出必需的盈余，于我们的幸福并没有太大裨益。相比于财富，人的自身对于人的幸福来说更为重要，虽然如此，但普通人对财富的追求要比对精神情趣的追求更为拼命。由于他们内心空虚、思想匮乏、感觉迟钝，所以他们就加入了社交圈子。社交圈中也都是和他们一样的人，“羽毛相同的鸟儿会聚集在一起”（荷马）。他们聚集在一起娱乐消遣，这种娱乐始于放纵感官，沉溺于声色享乐，而终结于荒唐无度。 青年人首先需要学习的就是忍受孤独，因为幸福和安乐就是从孤独中产生的。从此得出，处境最好的人就是那些只依赖自己，能从万物中感悟自身的人。当一个人独处时陪伴自己的，别人无法予夺的内在素质，亦即一个人的自身，之于一切他所拥有的财富以及他在别人心中的形象都更加重要。如果一个人的精神世界丰富的话，他单独一人的时候就能够徜徉在自己的精神世界中，悠然自得。 我们展现出的表象——亦即我们在他人眼中的形象——往往被我们过于重视。为了增进幸福这一目标，我们应该对这一人性的弱点加以限制；应该仔细地思考以及恰当地评价其真正的价值，尽量使我们对他人意见的敏感度降低，不管是受到他人意见的安慰还是伤害都应该这样，因为这两者是一条线的两端。不然，人们就会被他人的看法所奴役。差不多每个人穷尽一生努力拼搏，克服了艰难险阻，最终目的就是为了让他人对自己高看一眼。人们费尽心思追逐官职、头衔、勋章和财富，最主要的目标都是获得他人的尊重，甚至从事科学和艺术的根本目标也是如此。通过这些情况可以很遗憾地看出来人类是多么愚蠢。人们经常犯的错误就是过于看重他人的意见和看法。 理性的人追求的并非快乐，而只是避免痛苦。”这句话包含了以下真理：一切快乐的本质都是具有否定性质的，而痛苦则有着肯定性质的本质。 这条戒律告诉我们不应该把生活的愉悦和快乐当成追求的目标；而是应该努力避开生活中各种各样的灾祸。如果这个途径是错的，那么伏尔泰的话也就没有道理了——他说：“快乐只是一场梦，而痛苦却是真实的。” 一个人最幸运的就是一生中没有遭受过巨大的精神痛苦或肉体痛苦，而并非曾享受过多少强烈的快乐。在人生的幸福方面，后一个是错误的衡量标准。 我们应该将自己对快乐、财富、地位、荣誉等事物的渴望控制在一个合理范围内，因为巨大的不幸正是这些渴望及对它们的追逐导致的。因此，使我们的欲求降低是非常聪明而合理的，因为很容易就会遭受巨大的不幸。 所以，对于我们生活的舒适程度来说，健康是首位，处于第二位的是维持生存的手段，也就是无须辛劳的收入。荣誉、地位和名声——虽然很多人认为这些东西很有价值——但却无法与关键的好处相媲美，或者取而代之；必要时，为了前两种好处，我们应该毫不犹豫地将这第三种好处抛弃。","categories":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}],"tags":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/tags/随笔杂记/"}],"keywords":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}]},{"title":"【关于我】My first blog","slug":"my-first-blog","date":"2019-02-04T02:42:44.000Z","updated":"2020-10-13T13:52:01.527Z","comments":true,"path":"my-first-blog/","link":"","permalink":"http://yoursite.com/my-first-blog/","excerpt":"我是龙娅婷，欢迎来到我的博客！以后我会将生活中有意义的事情放到网站上作为记录。目前大致有以下几个方面：1. 科研学习2. 读书笔记3. 吉他","text":"我是龙娅婷，欢迎来到我的博客！以后我会将生活中有意义的事情放到网站上作为记录。目前大致有以下几个方面：1. 科研学习2. 读书笔记3. 吉他 大致就是这些啦，以后如果有新的内容，也会不定期更新到网站上面。嘻嘻嘻(●ˇ∀ˇ●) 更多关于我，请点这里","categories":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}],"tags":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/tags/随笔杂记/"}],"keywords":[{"name":"随笔杂记","slug":"随笔杂记","permalink":"http://yoursite.com/categories/随笔杂记/"}]}]}